<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" xmlns:m="http://www.w3.org/1998/Math/MathML" xmlns:pls="http://www.w3.org/2005/01/pronunciation-lexicon" xmlns:ssml="http://www.w3.org/2001/10/synthesis" xmlns:svg="http://www.w3.org/2000/svg">
<head>
  <meta charset="UTF-8" />
  <title>12. Productionizing an Angular App</title>
  <link type="text/css" rel="stylesheet" media="all" href="style.css" />
  <link type="text/css" rel="stylesheet" media="all" href="core.css" />
</head>
<body>
  <div id="sbo-rt-content"><section data-type="chapter" epub:type="chapter" data-pdf-bookmark="Chapter 12. Productionizing an Angular App"><div class="chapter" id="chapter-12">
<h1><span class="label">Chapter 12. </span>Productionizing an Angular App</h1>


<p>In all the chapters so far, we have talked about the various bits and pieces that add up to an Angular application.<a data-type="indexterm" data-primary="productionizing Angular apps" id="ix_prod"></a> We started at the very basic, and went to the more detailed and complex, from simple components to routing and server calls. But through all this, we focused on functionality and getting different bits to interact and play well together. At this point, you as a developer are ready to tackle 90% of most Angular application needs.</p>

<p>In this chapter, we will focus on what it takes to get that application you have built out into production in a performant manner. We will cover all the things you will have to keep in mind when deploying your Angular applications to production, as well as some other concerns that you may not have thought of. We will cover how to build an Angular app for production, how to reduce the size of the build, how to improve the performance, and even briefly cover other concerns like SEO.</p>






<section data-type="sect1" data-pdf-bookmark="Building for Production"><div class="sect1" id="idm139828109418880">
<h1>Building for Production</h1>

<p>So far, whenever we run our application, we usually ask the Angular CLI to serve our<a data-type="indexterm" data-primary="productionizing Angular apps" data-secondary="building for production" id="ix_prodbld"></a> application, by running:</p>
<pre data-type="programlisting">
<strong>ng serve</strong>
</pre>

<p>This runs the Angular compiler, and builds and serves your Angular application using the internal server that the Angular CLI has. You could use the <code>build</code> command to generate the files to serve it for production as well. The command would simply be:</p>
<pre data-type="programlisting">
<strong>ng build</strong>
</pre>

<p>This would by default generate all your compiled files in a folder called <em>dist/</em>. You can then simply copy everything from this folder, put it on an HTTP server, and be off and running. But it is not what you should be doing! The build that gets generated by default is a suboptimal, overweight build that would make your production application slow to load and slow to run (comparatively, that is!). Angular allows you to build an optimized version of your application, so let’s see how we might do that.</p>








<section data-type="sect2" data-pdf-bookmark="Production Build"><div class="sect2" id="idm139828109410944">
<h2>Production Build</h2>

<p>The simplest thing we can do to create a better build for production is to use the <code>prod</code> flag with the <code>ng build</code> command. <a data-type="indexterm" data-primary="productionizing Angular apps" data-secondary="building for production" data-tertiary="ng build --prod command on CLI" id="idm139828109408512"></a><a data-type="indexterm" data-primary="ng build --prod command" id="idm139828109407152"></a>Simply, you can run:</p>
<pre data-type="programlisting">
<strong>ng build --prod</strong>
</pre>

<p>This does a few things of note:</p>
<dl>
<dt>Bundling</dt>
<dd>
<p>When we write our code, we like to keep it in nice, disparate files to make it easier to read, manage, and update.<a data-type="indexterm" data-primary="bundling app and library files" id="idm139828109390672"></a> But for the end browser, loading 1,000 files is not as efficient as loading, say, 4 or 5 files. Angular CLI bundles all the application and library files into a few bundles to make it faster to load in the browser. Note that bundling happens both with and without the <code>--prod</code> flag.</p>
</dd>
<dt>Minification</dt>
<dd>
<p>Spaces, indentation, and the like are useful for us developers, but the browser and systems running the code don’t care.<a data-type="indexterm" data-primary="minification in production builds" id="idm139828109387664"></a> Minification is the process of removing all unneeded spaces. The <code>--prod</code> does this for us, thus saving a few bytes of space in the final build.</p>
</dd>
<dt>Uglification</dt>
<dd>
<p>The <code>--prod</code> flag uglifies the code as well, which is the process of replacing all nice, readable variable and function names with a smaller, two or three character name to save a few bytes.<a data-type="indexterm" data-primary="uglification of code in production builds" id="idm139828109384480"></a> The overall code is much more efficient and smaller to load.</p>
</dd>
<dt>AOT</dt>
<dd>
<p>We will talk about Ahead-of-Time (AOT) compilation in a little bit more detail in the following section, but in a nutshell, AOT compilation allows us to further reduce the size of code by dropping unused paths.<a data-type="indexterm" data-primary="ahead-of-time (AOT) compilation" id="idm139828109382176"></a></p>
</dd>
<dt>Run Angular in production mode</dt>
<dd>
<p>When we run Angular using <code>ng serve</code> (or build and run it without the <code>prod</code> flag), the Angular library performs some checks each time it renders in the UI.<a data-type="indexterm" data-primary="production mode" data-secondary="running Angular in" id="idm139828109379280"></a> Think of these as training wheels, to ensure that the developer doesn’t end up developing something that invalidates or goes against Angular’s patterns. These checks can add up to a few precious milliseconds during each render, and thus it is recommended that we turn these off in the final production build. The <code>--prod</code> does this for you.</p>
</dd>
<dt>Dead code elimination</dt>
<dd>
<p>There are times when you erroneously leave a module imported, or you haven’t ended up using all of the functionality from a module. The build process removes all unused code and unreferenced modules, thus dropping the bundle size <span class="keep-together">further</span>.</p>
</dd>
</dl>

<p>At the end of this, you should have the files you need to deploy in the <em>dist</em> folder, each with an individual hash based on the contents. This would be a pretty optimal build that should be good in a majority of cases.</p>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Ahead-of-Time (AOT) Compilation and Build Optimizer"><div class="sect2" id="idm139828109374048">
<h2>Ahead-of-Time (AOT) Compilation and Build Optimizer</h2>

<p>We briefly mentioned Ahead-of-Time compilation in the previous section. This mode has become enabled by default in any production build since the 1.5 version of the Angular CLI.<a data-type="indexterm" data-primary="productionizing Angular apps" data-secondary="building for production" data-tertiary="ahead-of-time compilation and Build Optimizer" id="idm139828109372320"></a><a data-type="indexterm" data-primary="ahead-of-time (AOT) compilation" data-secondary="and Build Optimizer" id="idm139828109371072"></a></p>

<p>Angular applications use what we call Just-in-Time (JIT) compilation, where the application is compiled at runtime in the browser before running.<a data-type="indexterm" data-primary="just-in-time (JIT) compilation" id="idm139828109369568"></a> This is also the default when you run the Angular application using <code>ng serve</code> or <code>ng build</code>.</p>

<p>In production mode, Angular uses AOT for compilation, which means that Angular compiles as much of the application as possible upfront. Thus, when the application is served to the browser, it is already precompiled and optimal, thus allowing the browser to quickly render and execute the application.</p>

<p>Furthermore, as part of the compilation process, all HTML templates and CSS are inlined within the application bundle, thus saving asynchronous requests to load them later.</p>

<p>There is also a significant reduction in the size of the built bundle, as the Angular compiler, which constitutes almost half of the Angular library, can be omitted. The compiler’s work, of checking templates, bindings, and the like, can now be done at compile time, thus catching them earlier rather than after deploying the application.</p>

<p>Build Optimizer is a webpack plug-in that was introduced by the Angular team to further optimize the bundle beyond what webpack is capable of.<a data-type="indexterm" data-primary="Build Optimizer" id="idm139828109365168"></a> In particular, it focuses on removing some of the decorators and other code that is not relevant for the final build. It only works with AOT, so you shouldn’t end up using it with non-AOT builds. Since Angular CLI 1.5, this has been enabled by default whenever you do a production build in Angular along with AOT.</p>

<p>There is a lot more to the AOT compiler, and the options it provides and how we can modify and play around with it. You can read up on it in more detail in <a href="https://angular.io/guide/aot-compiler">the official Angular docs</a>.</p>

<p>Thus, unless there is a very strong reason (and there usually isn’t), leave the AOT enabled when you generate the final build, which should give you as close to an optimal build with minimal additional work.</p>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Base Href"><div class="sect2" id="idm139828109482752">
<h2>Base Href</h2>

<p>One additional concern when building and deploying any Single-Page Application is where it is served from. In cases where your application is served from the root domain (say, <em>www.mytestpage.com</em>), the default should work.<a data-type="indexterm" data-primary="productionizing Angular apps" data-secondary="building for production" data-tertiary="base href tag" id="idm139828109480544"></a></p>

<p>In other cases though, where your application is served not from the root domain (say, <em>www.mytestpage.com/app</em> or something similar), then it is important that we update our <code>&lt;base&gt;</code> tag in the <em>index.html</em>.<a data-type="indexterm" data-primary="base HTML tag" id="idm139828109477616"></a></p>

<p>The HTML <code>base</code> tag is responsible for setting the base path for all relative URLs in our application.<a data-type="indexterm" data-primary="URLs" data-secondary="base path for relative URLs in an application" id="idm139828109476048"></a> These include, but are not limited to, CSS/style files, our JavaScript application and library files, images, and more.</p>

<p>Let’s take the case of serving an application from <em>www.mytestpage.com/app</em>, and see how the <code>base</code> tag would impact this:</p>
<ol>
<li>
<p>Let’s assume that we didn’t have a <code>&lt;base&gt;</code> tag, or the tag was <code>&lt;base href="/"&gt;</code>. In this case, when we have the script tag <code>&lt;script src="js/main.js"&gt;</code>, then the browser will make a request to <em>www.mytestpage.com/js/main.js</em>.</p>
</li>
<li>
<p>Now let’s assume that we had the following base tag: <code>&lt;base href="/app"&gt;</code>. In this case, when we have the script tag <code>&lt;script src="js/main.js"&gt;</code>, then the browser will make a request to <em>www.mytestpage.com/app/js/main.js</em>.</p>
</li>

</ol>

<p>As you can clearly see, the second request is the correct one, and ensures that the necessary images and scripts are loaded correctly.</p>

<p>How does this play into our Angular application? When we build our Angular application using the Angular CLI, we can specify or overwrite the <code>base</code> <code>href</code> value. Continuing our example from earlier, we could build our application as follows:</p>
<pre data-type="programlisting">
<strong>ng build --base-href /app/</strong>
</pre>

<p>This would ensure that the generated <em>index.html</em> has the correct base tag for your deployment.</p>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Deploying an Angular Application"><div class="sect2" id="idm139828109482128">
<h2>Deploying an Angular Application</h2>

<p>There are a ton more options when building your Angular application for deployment,<a data-type="indexterm" data-primary="deploying Angular applications" id="idm139828109462528"></a><a data-type="indexterm" data-primary="productionizing Angular apps" data-secondary="building for production" data-tertiary="deploying applications" id="idm139828109461760"></a><a data-type="indexterm" data-primary="command-line interface (CLI)" data-secondary="Angular CLI build wiki" id="idm139828109460528"></a> and you can read up on all the options and their uses at <a href="https://github.com/angular/angular-cli/wiki/build">the Angular CLI build wiki</a>.</p>

<p>But for the purpose of deploying a mostly performant Angular application, the options we just reviewed cover the majority of the use cases. At this point, you would have a <em>dist/</em> folder (unless you have overriden the default) with generated files. Each generated file would also have a hash representing the contents.</p>

<p>At this point, you should be able to take the entire folder, drop it in to your frontend server (be it nginx, Apache, or whatever), and start serving your Angular application. As long as you serve the entire folder, and your base path (as we saw in the preceding section) is set correctly, you should be off to the races. There are a few more concerns that we will cover in the next section, from handling caching, deep-linking, and others, but this would be the base you will build off of.<a data-type="indexterm" data-primary="productionizing Angular apps" data-secondary="building for production" data-startref="ix_prodbld" id="idm139828109456576"></a></p>
</div></section>





</div></section>













<section data-type="sect1" data-pdf-bookmark="Other Concerns"><div class="sect1" id="idm139828109418256">
<h1>Other Concerns</h1>

<p>In the previous section, we saw the bare minimum it would take to drop a mostly optimal build into our frontend server and have it start serving traffic. In this section, we will go slightly deeper into specific concerns that we need to think about to ensure better performance or proper functionality.</p>








<section data-type="sect2" data-pdf-bookmark="Caching"><div class="sect2" id="idm139828109453152">
<h2>Caching</h2>

<p>The first topic we will start with is caching.<a data-type="indexterm" data-primary="productionizing Angular apps" data-secondary="caching" id="idm139828109451584"></a><a data-type="indexterm" data-primary="caching" id="idm139828109450592"></a> And in this section, we are particularly talking about frontend code caching, not the API response caching. That is, how and when should we cache our <em>index.html</em>, our JS files and CSS files, and how long should they remain cached.<a data-type="indexterm" data-primary="index.html file" data-secondary="caching" id="idm139828109603440"></a><a data-type="indexterm" data-primary="JavaScript" data-secondary="caching JS files in Angular applications" id="idm139828109602464"></a><a data-type="indexterm" data-primary="CSS" data-secondary="caching CSS files in Angular applications" id="idm139828109601552"></a></p>

<p>When we create our production builds, notice that our generated files (other than the <em>index.html</em>) have a hash in the filename (like <em>inline.62ca64ed6c08f96e698b.bundle.js</em>). This hash is generated based on the contents of the file, so if the content of the file changes, the hash in the filename also changes! Also, our generated <em>index.html</em> explicitly refers to these generated files and loads them as scripts or as styles.</p>

<p>This gives us a great mechanism now for caching these files on the browser. Our simple rule of thumb for caching now becomes:</p>

<ul>
<li>
<p>We <em>never</em> cache our <em>index.html</em> file on the browser. This would mean setting the <code>Cache-Control</code> header on your server just for the <em>index.html</em> to be set to <code>no-cache</code>, <code>no-store</code>, <code>must-revalidate</code>. Note that this is only for the <em>index.html</em> file, and not for all other files from your frontend server. The <em>index.html</em> file is tiny anyway, and we can quickly revalidate it if needed.</p>
</li>
<li>
<p>We <em>always</em> cache all other asset files, like our JavaScript bundles and our CSS files, as long as possible. Again, because the asset filenames themselves will change, we can be guaranteed that our noncached <em>index.html</em> will always load the correct asset files. And those files can remain cached indefinitely. This ensures a great second load performance, where all asset files can be served from the cache.</p>
</li>
</ul>

<p>Now, let’s talk through a few potential user scenarios to make it clear how this caching strategy handles them:</p>
<dl>
<dt>First load, new user</dt>
<dd>
<p>For the very first request from a fresh user, the browser first requests the <em>index.html</em> from the server. The server returns it, after which the browser processes the <em>index.html</em>. Based on the files it then asks for, the browser makes request for the styles and scripts from the server. Since it is the first request, none of the data is cached, and all the required files are served by the server. Finally, the app is up and running after all the files are loaded.</p>
</dd>
<dt>Second load, repeat user</dt>
<dd>
<p>The second time the user comes back to our application, the browser again requests the <em>index.html</em> from the frontend server. This is because the <em>index.html</em> has not been cached according to our <code>Cache-Control</code> headers. The frontend server responds with the latest content for <em>index.html</em>, which has not changed. Now, the browser looks at the script and style files it has to load, which has also not changed. But these files are perpetually cached on the browser. Thus, the browser doesn’t need to make server requests to load them, and instead loads them from the local cache. Our app is now up and running immediately almost as soon as the <em>index.html</em> finishes loading.</p>
</dd>
<dt>First load, new user, website updated</dt>
<dd>
<p>In case a new user visits after we have updated our website source code, the flow followed is exactly the same as the first load case for a new user.</p>
</dd>
<dt>Second load, repeat user, website updated</dt>
<dd>
<p>In this case, the user had visited our website in the past, and has a cached version of the styles and scripts on his browser. Now when we visit the website, after we have pushed out a new update, the very first thing that happens will not change. The browser will make a request for <em>index.html</em> from the frontend server. The server will return the new version of the <em>index.html</em> that points to the new script and style tags. Now when the browser tries to load these, it will realize that it doesn’t have a cached version of the script and style tags (because the content-hash in the filename has changed). It will again make a request to the server to load all these files, and thus the flow becomes very similar to the first flow where the user is visiting for the first time.</p>
</dd>
</dl>

<p>Thus, we can see that with this kind of caching mechanism, we get the best of both worlds, which is ensuring that we cache as much as possible, without breaking the user experience in case of pushing out updates to our web application.</p>
</div></section>













<section data-type="sect2" data-pdf-bookmark="API/Server Calls and CORS"><div class="sect2" id="idm139828109578048">
<h2>API/Server Calls and CORS</h2>

<p>The second topic worth covering is how to set up your web application so that it can make server calls successfully.<a data-type="indexterm" data-primary="productionizing Angular apps" data-secondary="API/server calls and CORS" id="idm139828109576224"></a> The browser, for security reasons, prevents your web application from making asynchronous calls outside of its domain (this includes sub-domains as well). That is, your web application running on <em>www.mytestpage.com</em> cannot make an AJAX call to <em>www.mytestapi.com</em>, or even to <em>api.mytestpage.com</em>.</p>

<p>We get around this during development by using a proxy as part of the Angular CLI (remember <code>ng serve --proxy proxy.config.json</code>?).<a data-type="indexterm" data-primary="ng serve --proxy proxy.config.json command" id="idm139828109572608"></a><a data-type="indexterm" data-primary="proxy server, setting up" id="idm139828109571872"></a> The proxy ensured that our requests were made to the same frontend server (and domain) serving our static files, and it then was responsible to proxy the calls to the actual API server.</p>

<p>When we deploy our web application in production, you will also need to set up something similar to this.<a data-type="indexterm" data-primary="servers" data-secondary="API/server calls in production apps" id="idm139828109570288"></a> That is, your frontend server will be the one getting the initial API calls, and it then has to proxy those requests forward to the actual API server.<a data-type="indexterm" data-primary="API/server calls" id="idm139828109569008"></a></p>

<p>Your frontend server would end up behaving something like shown in <a data-type="xref" href="#fig1201">Figure 12-1</a>.</p>

<figure><div id="fig1201" class="figure">
<img src="images/auar_12in01.png" alt="Sample Routing At Server" />
<h6><span class="label">Figure 12-1. </span>Simple end-to-end architecture for a web application</h6>
</div></figure>

<p>We have used NGINX as an example, but you could easily replace it with Apache or IIS configuration, which does exactly the same. We simply route all requests to our API server (<em>/api/</em>), and all others to our static files, which is our Angular application.</p>

<p>If you really can’t do this (for whatever reason), then there is a second option, which again requires changes on your server.<a data-type="indexterm" data-primary="Cross-Origin Resource Sharing (CORS)" id="idm139828109563552"></a> We can enable Cross-Origin Resource Sharing (CORS) on our server, which can allow pages from different origins (read domains or subdomains) to make requests, bypassing the browser security restrictions. It simply requires the<a data-type="indexterm" data-primary="Access-Control-Allow-Origin: header" id="idm139828109562464"></a> API server to respond with an additional header:</p>

<pre data-type="programlisting">Access-Control-Allow-Origin: *</pre>

<p>You can also restrict this header to allow only requests from certain origins, instead of all origins like we have done here. Once you do this, then you can allow your web application to directly make requests to the API server. You can learn more about CORS <a href="https://en.wikipedia.org/wiki/Cross-origin_resource_sharing">here</a>, and see how to configure it for your particular server <a href="https://enable-cors.org/server.html">here</a>.</p>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Different Environments"><div class="sect2" id="idm139828109577424">
<h2>Different Environments</h2>

<p>Another common requirement when building an application is having different configuration for different environments.<a data-type="indexterm" data-primary="productionizing Angular apps" data-secondary="configurations for different environments" id="idm139828109557168"></a> For example, you might have different API keys for your client-side tracking libraries, or you might even have different server URLs to configure for test versus production.</p>

<p>In such cases, you can use the concept of <em>environments</em> in Angular.<a data-type="indexterm" data-primary="environments" id="idm139828109555072"></a> By default, when you create a new Angular application using the Angular CLI, it creates an <em>src/environments</em> folder, with one file per environment. By default, the Angular CLI makes the properties available in the <em>environment.ts</em> file available across your application. But you can override it by running Angular with:</p>
<pre data-type="programlisting">
<strong>ng serve --env=prod</strong>
</pre>

<p>When you run it like this, it uses the value passed to <code>--env</code> flag, and loads and makes available the corresponding environments file. In this case, it would make the <em>environment.prod.ts</em> file available.</p>

<p>In your application, you can simply import the main <em>environment</em> file like so, and Angular will ensure you get the correct properties based on the flag:</p>

<pre data-type="programlisting" data-code-language="ts"><code class="kr">import</code> <code class="p">{</code> <code class="nx">environment</code> <code class="p">}</code> <code class="nx">from</code> <code class="s1">'./environments/environment'</code><code class="p">;</code></pre>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Handling Deep-Linking"><div class="sect2" id="idm139828109558528">
<h2>Handling Deep-Linking</h2>

<p>The last thing to have a really complete web application is to support deep-linking.<a data-type="indexterm" data-primary="productionizing Angular apps" data-secondary="handling deep-linking" id="idm139828109138608"></a><a data-type="indexterm" data-primary="deep-linking, handling in production apps" id="idm139828109137664"></a> We already saw how to enable routing for your Angular application in <a data-type="xref" href="ch11.html#chapter-11">Chapter 11</a>. Once you deployed your Angular application, you might notice something weird or annoying. When you navigate to the base route of your application, your frontend server serves the <em>index.html</em>, and your application works. Any routes from that point on work as you would expect it to. But if you try to directly link to a route within your application, it might not.<a data-type="indexterm" data-primary="routing" data-secondary="directly linking to routes within an application" id="idm139828109134176"></a></p>

<p>This is due to how we have set up our frontend server to serve the static files necessary for the Angular application. Let’s take a closer look at what is happening here:</p>
<ol>
<li>
<p>If you request for the base route, your frontend server translates that to serve the <em>index.html</em> file. This also loads all the relevant scripts and CSS, and bootstraps your Angular application.</p>
</li>
<li>
<p>After this, any link within your application is intercepted by Angular within the browser, and Angular serves the relevant content for that route. So while the route in your browser changes, it is actually not making a request to the server for that new route. It behaves like a Single-Page Application should.</p>
</li>
<li>
<p>Now in the case that we want to directly open a certain route, when we enter that route in the browser, the browser makes that request to our frontend server. Unless you have set up your frontend server configuration correctly, it is not going to find any match for this URL (which is a frontend only route). Thus it fails to serve and most often ends up serving the <code>404</code> page (or whatever you might have configured).</p>
</li>

</ol>

<p>To work around this, we need to set up our frontend server to serve requests as follows, in order<a data-type="indexterm" data-primary="servers" data-secondary="setting up frontend server to serve requests by priority" id="idm139828109121200"></a> of priority:</p>
<ol>
<li>
<p>Recognize all API requests, and proxy that to the actual backend server to serve those requests. Keep API requests under a common path, so that you can proxy all of them consistently and first (for example, always beginning API requests with <code>/api</code>).</p>
</li>
<li>
<p>Match and serve any request that translates to a static file (say, a JS, CSS file, or something like those).</p>
</li>
<li>
<p>Either serve all remaining requests with the <em>index.html</em> file, or match all frontend routes (in addition to the base <code>/</code> route) with the <em>index.html</em>.</p>
</li>

</ol>

<p>An easy way to do this with an NGINX server would be to use the <code>try_files</code> directive to serve the <em>index.html</em> as a fallback in case a file with the path is not found.</p>

<p>Once you have set up your frontend server as described, then a deep-linked route will end up matching the last category of requests, and the <em>index.html</em> will be served. Once the <em>index.html</em> loads and Angular is bootstrapped, Angular then takes over for all further routing and loading necessary content based on the route in the browser.</p>
<div data-type="warning" epub:type="warning"><h6>Warning</h6>
<p>Make sure your <code>base</code> tag is set up correctly so that the web page knows where to load the static files and relative paths from.<a data-type="indexterm" data-primary="base HTML tag" id="idm139828109110240"></a> Otherwise, your Angular application will not work even if you have set up your frontend server correctly.</p>
</div>

<p>You can look at the <a href="https://angular.io/guide/deployment#routed-apps-must-fallback-to-indexhtml">official Angular docs</a> for an updated set of configurations that works for different frontend servers. Configurations for NGINX, Apache, IIS, and more are available there.</p>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Lazy Loading"><div class="sect2" id="idm139828109139712">
<h2>Lazy Loading</h2>

<p>One more technique for a highly performant app, which we very briefly touched upon in <a data-type="xref" href="ch11.html#chapter-11">Chapter 11</a> when we were talking about routing in Angular, is lazy loading. <a data-type="indexterm" data-primary="lazy loading" id="ix_lzyld"></a><a data-type="indexterm" data-primary="productionizing Angular apps" data-secondary="lazy loading" id="ix_prodlzy"></a>Once we introduced the concept of routing into our Angular applications, you might have realized that not all of the routes are really necessary or need to be loaded.</p>

<p>So one common trick that we use to increase the performance and reduce the initial load time is to try to load the bare minimum up front in the initial request, and defer loading everything else to as and when it’s needed. We accomplish this by leveraging the Angular routing and using what we call child routes.</p>

<p>The technique in a nutshell <a data-type="indexterm" data-primary="routing" data-secondary="in lazy loading applications" id="ix_rtelzy"></a>is as follows:</p>
<ol>
<li>
<p>Instead of defining all our routes up front, we break up our application into smaller modules, each with their routes defined in self-contained units.</p>
</li>
<li>
<p>The respective components are now registered at these submodule level only, and not at the main application-level module.</p>
</li>
<li>
<p>We register all these routes as child routes in each individual module.</p>
</li>
<li>
<p>At the application level, we change our routing to instead point certain subpaths at the new module, rather than the individual routes.</p>
</li>

</ol>

<p>Now, when we run our application, Angular will load the bare minimal code up front, and load the remaining modules as and when we navigate to those routes.</p>

<p>Let’s take our application from the previous chapter, and see how to convert it into a lazy-loading application. You can use the code from <em>chapter11/route-guards</em> as the base to convert into the lazy-loading application. Before we get into the nitty gritties, let’s talk through the changes we will make:</p>

<ul>
<li>
<p>We will create two new modules, a <code>UserModule</code> and a <code>StockModule</code>. The <code>UserModule</code> will hold the Login and Register components, and the routes for them. The <code>StockModule</code> would hold the routes and components related to showing and creating stocks. Note that for now, we will leave the services registered at the parent level, though you could optimize further and split them into related modules only.</p>
</li>
<li>
<p>We will redefine our routes to have a nice parent path for all related and grouped routes. So our login and register routes will move under a <code>user</code> parent path, and the stock routes will move under a <code>stock</code> parent path. This also means that all our redirects and navigation within the app will have to change to refer to the new URLs.</p>
</li>
<li>
<p>Finally, we will change the main <code>AppModule</code> and the routes to use lazy routing and register only relevant components and services.</p>
</li>
</ul>

<p>Let’s walk through these changes step by step, along with the respective code.</p>

<p>First, we will generate two new modules, along with their corresponding routing module:</p>
<pre data-type="programlisting">
<strong>ng generate module stock --routing</strong>
<strong>ng generate module user --routing</strong>
</pre>

<p>This will generate the following four files:</p>

<ul>
<li>
<p><em>src/app/stock/stock.module.ts</em></p>
</li>
<li>
<p><em>src/app/stock/stock-routing.module.ts</em></p>
</li>
<li>
<p><em>src/app/user/user.module.ts</em></p>
</li>
<li>
<p><em>src/app/user/user-routing.module.ts</em></p>
</li>
</ul>

<p>Now let’s see how we will modify each one to set up our application for lazy loading. First, we’ll start with the <em>user-routing.module.ts</em> file:</p>

<pre data-type="programlisting" data-code-language="ts"><code class="kr">import</code> <code class="p">{</code> <code class="nx">NgModule</code> <code class="p">}</code> <code class="nx">from</code> <code class="s1">'@angular/core'</code><code class="p">;</code>
<code class="kr">import</code> <code class="p">{</code> <code class="nx">Routes</code><code class="p">,</code> <code class="nx">RouterModule</code> <code class="p">}</code> <code class="nx">from</code> <code class="s1">'@angular/router'</code><code class="p">;</code>
<code class="kr">import</code> <code class="p">{</code> <code class="nx">LoginComponent</code> <code class="p">}</code> <code class="nx">from</code> <code class="s1">'./login/login.component'</code><code class="p">;</code>
<code class="kr">import</code> <code class="p">{</code> <code class="nx">RegisterComponent</code> <code class="p">}</code> <code class="nx">from</code> <code class="s1">'./register/register.component'</code><code class="p">;</code>

<code class="kr">const</code> <code class="nx">routes</code>: <code class="kt">Routes</code> <code class="o">=</code> <code class="p">[</code>
  <code class="p">{</code> <code class="nx">path</code><code class="o">:</code> <code class="s1">'login'</code><code class="p">,</code> <code class="nx">component</code>: <code class="kt">LoginComponent</code> <code class="p">},</code>
  <code class="p">{</code> <code class="nx">path</code><code class="o">:</code> <code class="s1">'register'</code><code class="p">,</code> <code class="nx">component</code>: <code class="kt">RegisterComponent</code> <code class="p">},</code>
<code class="p">];</code>

<code class="err">@</code><code class="nx">NgModule</code><code class="p">({</code>
  <code class="nx">imports</code><code class="o">:</code> <code class="p">[</code><code class="nx">RouterModule</code><code class="p">.</code><code class="nx">forChild</code><code class="p">(</code><code class="nx">routes</code><code class="p">)],</code>
  <code class="nx">exports</code><code class="o">:</code> <code class="p">[</code><code class="nx">RouterModule</code><code class="p">]</code>
<code class="p">})</code>
<code class="kr">export</code> <code class="kr">class</code> <code class="nx">UserRoutingModule</code> <code class="p">{</code> <code class="p">}</code></pre>

<p>We simply add our two routes for login and register to the <code>routes</code> array. These have been moved from the <em>app-routes.module.ts</em> file. Also, note one major difference. Previously, whenever we registered our routes, we registered them as <code>RouterModule.forRoot</code>. Now we have started registering them as child routes.<a data-type="indexterm" data-primary="parent/root routes and child routes" id="idm139828108959104"></a><a data-type="indexterm" data-primary="child routes" id="idm139828108958448"></a> This is how Angular differentiates between parent/root routes and child routes.</p>

<p>Our <em>user.module.ts</em> will also change as follows:</p>

<pre data-type="programlisting" data-code-language="ts"><code class="kr">import</code> <code class="p">{</code> <code class="nx">NgModule</code> <code class="p">}</code> <code class="nx">from</code> <code class="s1">'@angular/core'</code><code class="p">;</code>
<code class="kr">import</code> <code class="p">{</code> <code class="nx">CommonModule</code> <code class="p">}</code> <code class="nx">from</code> <code class="s1">'@angular/common'</code><code class="p">;</code>

<code class="kr">import</code> <code class="p">{</code> <code class="nx">LoginComponent</code> <code class="p">}</code> <code class="nx">from</code> <code class="s1">'./login/login.component'</code><code class="p">;</code>
<code class="kr">import</code> <code class="p">{</code> <code class="nx">RegisterComponent</code> <code class="p">}</code> <code class="nx">from</code> <code class="s1">'./register/register.component'</code><code class="p">;</code>


<code class="kr">import</code> <code class="p">{</code> <code class="nx">UserRoutingModule</code> <code class="p">}</code> <code class="nx">from</code> <code class="s1">'./user-routing.module'</code><code class="p">;</code>
<code class="kr">import</code> <code class="p">{</code> <code class="nx">FormsModule</code> <code class="p">}</code> <code class="nx">from</code> <code class="s1">'@angular/forms'</code><code class="p">;</code>

<code class="err">@</code><code class="nx">NgModule</code><code class="p">({</code>
  <code class="nx">imports</code><code class="o">:</code> <code class="p">[</code>
    <code class="nx">CommonModule</code><code class="p">,</code>
    <code class="nx">FormsModule</code><code class="p">,</code>
    <code class="nx">UserRoutingModule</code>
  <code class="p">],</code>
  <code class="nx">declarations</code><code class="o">:</code> <code class="p">[</code>
    <code class="nx">LoginComponent</code><code class="p">,</code>
    <code class="nx">RegisterComponent</code><code class="p">,</code>
  <code class="p">]</code>
<code class="p">})</code>
<code class="kr">export</code> <code class="kr">class</code> <code class="nx">UserModule</code> <code class="p">{</code> <code class="p">}</code></pre>

<p>We end up with a very simple <code>UserModule</code>, which just declares the two components: <code>LoginComponent</code> and the <code>RegisterComponent</code>. Also note that we have imported the <code>FormsModule</code>, because we use <code>ngModel</code> binding in the forms. We don’t define the services here, because we rely on them from the main <code>AppModule</code> instead.</p>

<p>Our changes to the <em>stock-routing.module.ts</em> file are also similar:</p>

<pre data-type="programlisting" data-code-language="ts"><code class="kr">import</code> <code class="p">{</code> <code class="nx">NgModule</code> <code class="p">}</code> <code class="nx">from</code> <code class="s1">'@angular/core'</code><code class="p">;</code>
<code class="kr">import</code> <code class="p">{</code> <code class="nx">Routes</code><code class="p">,</code> <code class="nx">RouterModule</code> <code class="p">}</code> <code class="nx">from</code> <code class="s1">'@angular/router'</code><code class="p">;</code>
<code class="kr">import</code> <code class="p">{</code> <code class="nx">StockListComponent</code> <code class="p">}</code> <code class="nx">from</code> <code class="s1">'./stock-list/stock-list.component'</code><code class="p">;</code>
<code class="kr">import</code> <code class="p">{</code> <code class="nx">AuthGuardService</code> <code class="p">}</code> <code class="nx">from</code> <code class="s1">'app/services/auth-guard.service'</code><code class="p">;</code>
<code class="kr">import</code> <code class="p">{</code> <code class="nx">CreateStockComponent</code> <code class="p">}</code>
    <code class="nx">from</code> <code class="s1">'./create-stock/create-stock.component'</code><code class="p">;</code>
<code class="kr">import</code> <code class="p">{</code> <code class="nx">CreateStockDeactivateGuardService</code> <code class="p">}</code>
    <code class="nx">from</code> <code class="s1">'app/services/create-stock-deactivate-guard.service'</code><code class="p">;</code>
<code class="kr">import</code> <code class="p">{</code> <code class="nx">StockDetailsComponent</code> <code class="p">}</code>
    <code class="nx">from</code> <code class="s1">'./stock-details/stock-details.component'</code><code class="p">;</code>
<code class="kr">import</code> <code class="p">{</code> <code class="nx">StockLoadResolverService</code> <code class="p">}</code>
    <code class="nx">from</code> <code class="s1">'app/services/stock-load-resolver.service'</code><code class="p">;</code>

<code class="kr">const</code> <code class="nx">routes</code>: <code class="kt">Routes</code> <code class="o">=</code> <code class="p">[</code>
  <code class="p">{</code> <code class="nx">path</code><code class="o">:</code> <code class="s1">'list'</code><code class="p">,</code> <code class="nx">component</code>: <code class="kt">StockListComponent</code><code class="p">,</code>
    <code class="nx">canActivate</code><code class="o">:</code> <code class="p">[</code><code class="nx">AuthGuardService</code><code class="p">]</code> <code class="p">},</code>
  <code class="p">{</code> <code class="nx">path</code><code class="o">:</code> <code class="s1">'create'</code><code class="p">,</code> <code class="nx">component</code>: <code class="kt">CreateStockComponent</code><code class="p">,</code>
    <code class="nx">canActivate</code><code class="o">:</code> <code class="p">[</code><code class="nx">AuthGuardService</code><code class="p">],</code>
    <code class="nx">canDeactivate</code><code class="o">:</code> <code class="p">[</code><code class="nx">CreateStockDeactivateGuardService</code><code class="p">]</code> <code class="p">},</code>
  <code class="p">{</code> <code class="nx">path</code><code class="o">:</code> <code class="s1">':code'</code><code class="p">,</code> <code class="nx">component</code>: <code class="kt">StockDetailsComponent</code><code class="p">,</code>
    <code class="nx">canActivate</code><code class="o">:</code> <code class="p">[</code><code class="nx">AuthGuardService</code><code class="p">],</code>
    <code class="nx">resolve</code><code class="o">:</code> <code class="p">{</code> <code class="nx">stock</code>: <code class="kt">StockLoadResolverService</code> <code class="p">}</code> <code class="p">},</code>
<code class="p">];</code>

<code class="err">@</code><code class="nx">NgModule</code><code class="p">({</code>
  <code class="nx">imports</code><code class="o">:</code> <code class="p">[</code><code class="nx">RouterModule</code><code class="p">.</code><code class="nx">forChild</code><code class="p">(</code><code class="nx">routes</code><code class="p">)],</code>
  <code class="nx">exports</code><code class="o">:</code> <code class="p">[</code><code class="nx">RouterModule</code><code class="p">]</code>
<code class="p">})</code>
<code class="kr">export</code> <code class="kr">class</code> <code class="nx">StockRoutingModule</code> <code class="p">{</code> <code class="p">}</code></pre>

<p>Very similar to the <code>UserRoutingModule</code>, we have simply moved the stock list, create, and details routes to the <code>StockRoutingModule</code>. Do note that we dropped the prefix from the paths and just kept it relative to the current module. Other than prefilling the <code>routes</code> array, everything else is just the autogenerated code.</p>

<p>Our <code>StockModule</code> change is also trivial and straightforward:</p>

<pre data-type="programlisting" data-code-language="ts"><code class="kr">import</code> <code class="p">{</code> <code class="nx">NgModule</code> <code class="p">}</code> <code class="nx">from</code> <code class="s1">'@angular/core'</code><code class="p">;</code>
<code class="kr">import</code> <code class="p">{</code> <code class="nx">CommonModule</code> <code class="p">}</code> <code class="nx">from</code> <code class="s1">'@angular/common'</code><code class="p">;</code>

<code class="kr">import</code> <code class="p">{</code> <code class="nx">StockItemComponent</code> <code class="p">}</code> <code class="nx">from</code> <code class="s1">'./stock-item/stock-item.component'</code><code class="p">;</code>
<code class="kr">import</code> <code class="p">{</code> <code class="nx">CreateStockComponent</code> <code class="p">}</code> <code class="nx">from</code> <code class="s1">'./create-stock/create-stock.component'</code><code class="p">;</code>
<code class="kr">import</code> <code class="p">{</code> <code class="nx">StockListComponent</code> <code class="p">}</code> <code class="nx">from</code> <code class="s1">'./stock-list/stock-list.component'</code><code class="p">;</code>
<code class="kr">import</code> <code class="p">{</code> <code class="nx">StockDetailsComponent</code> <code class="p">}</code> <code class="nx">from</code> <code class="s1">'./stock-details/stock-details.component'</code><code class="p">;</code>


<code class="kr">import</code> <code class="p">{</code> <code class="nx">StockRoutingModule</code> <code class="p">}</code> <code class="nx">from</code> <code class="s1">'./stock-routing.module'</code><code class="p">;</code>
<code class="kr">import</code> <code class="p">{</code> <code class="nx">FormsModule</code> <code class="p">}</code> <code class="nx">from</code> <code class="s1">'@angular/forms'</code><code class="p">;</code>

<code class="err">@</code><code class="nx">NgModule</code><code class="p">({</code>
  <code class="nx">imports</code><code class="o">:</code> <code class="p">[</code>
    <code class="nx">CommonModule</code><code class="p">,</code>
    <code class="nx">FormsModule</code><code class="p">,</code>
    <code class="nx">StockRoutingModule</code>
  <code class="p">],</code>
  <code class="nx">declarations</code><code class="o">:</code> <code class="p">[</code>
    <code class="nx">StockDetailsComponent</code><code class="p">,</code>
    <code class="nx">StockItemComponent</code><code class="p">,</code>
    <code class="nx">StockListComponent</code><code class="p">,</code>
    <code class="nx">CreateStockComponent</code><code class="p">,</code>
  <code class="p">]</code>
<code class="p">})</code>
<code class="kr">export</code> <code class="kr">class</code> <code class="nx">StockModule</code> <code class="p">{</code> <code class="p">}</code></pre>

<p>We import the <code>FormsModule</code> along with declaring all the stock-related components. Now let’s take a look at the modified <code>AppModule</code> first before we go redefine the routes:</p>

<pre data-type="programlisting" data-code-language="ts"><code class="cm">/** No major changes in imports, skipping for brevity **/</code>

<code class="err">@</code><code class="nx">NgModule</code><code class="p">({</code>
  <code class="nx">declarations</code><code class="o">:</code> <code class="p">[</code>
    <code class="nx">AppComponent</code><code class="p">,</code>
  <code class="p">],</code>
  <code class="nx">imports</code><code class="o">:</code> <code class="p">[</code>
    <code class="nx">BrowserModule</code><code class="p">,</code>
    <code class="nx">HttpClientModule</code><code class="p">,</code>
    <code class="nx">AppRoutesModule</code><code class="p">,</code>
  <code class="p">],</code>
  <code class="nx">providers</code><code class="o">:</code> <code class="p">[</code>
    <code class="nx">StockService</code><code class="p">,</code>
    <code class="nx">UserService</code><code class="p">,</code>
    <code class="nx">UserStoreService</code><code class="p">,</code>
    <code class="nx">AuthGuardService</code><code class="p">,</code>
    <code class="nx">CreateStockDeactivateGuardService</code><code class="p">,</code>
    <code class="nx">StockLoadResolverService</code><code class="p">,</code>
    <code class="p">{</code>
      <code class="nx">provide</code>: <code class="kt">HTTP_INTERCEPTORS</code><code class="p">,</code>
      <code class="nx">useClass</code>: <code class="kt">StockAppInterceptor</code><code class="p">,</code>
      <code class="nx">multi</code>: <code class="kt">true</code><code class="p">,</code>
    <code class="p">}</code>
  <code class="p">],</code>
  <code class="nx">bootstrap</code><code class="o">:</code> <code class="p">[</code><code class="nx">AppComponent</code><code class="p">]</code>
<code class="p">})</code>
<code class="kr">export</code> <code class="kr">class</code> <code class="nx">AppModule</code> <code class="p">{</code> <code class="p">}</code></pre>

<p>The major change is the <code>declarations</code> array of the <code>NgModule</code>. All the components that we moved into the child modules have been removed from the declarations in the <code>AppModule</code> now. These components will now be loaded if necessary based on the route.</p>

<p>Now we can finally move to the <em>app-routes.module.ts</em> file, which changes as follows:</p>

<pre data-type="programlisting" data-code-language="ts"><code class="cm">/** Imports omitted for brevity **/</code>

<code class="kr">const</code> <code class="nx">appRoutes</code>: <code class="kt">Routes</code> <code class="o">=</code> <code class="p">[</code>
  <code class="p">{</code> <code class="nx">path</code><code class="o">:</code> <code class="s1">''</code><code class="p">,</code> <code class="nx">redirectTo</code><code class="o">:</code> <code class="s1">'user/login'</code><code class="p">,</code> <code class="nx">pathMatch</code><code class="o">:</code> <code class="s1">'full'</code> <code class="p">},</code>
  <code class="p">{</code> <code class="nx">path</code><code class="o">:</code> <code class="s1">'stock'</code><code class="p">,</code> <code class="nx">loadChildren</code><code class="o">:</code> <code class="s1">'app/stock/stock.module#StockModule'</code> <code class="p">},</code>
  <code class="p">{</code> <code class="nx">path</code><code class="o">:</code> <code class="s1">'user'</code><code class="p">,</code> <code class="nx">loadChildren</code><code class="o">:</code> <code class="s1">'app/user/user.module#UserModule'</code> <code class="p">},</code>
  <code class="p">{</code> <code class="nx">path</code><code class="o">:</code> <code class="s1">'**'</code><code class="p">,</code> <code class="nx">redirectTo</code><code class="o">:</code> <code class="s1">'user/register'</code> <code class="p">}</code>
<code class="p">];</code>

<code class="err">@</code><code class="nx">NgModule</code><code class="p">({</code>
  <code class="nx">imports</code><code class="o">:</code> <code class="p">[</code>
    <code class="nx">RouterModule</code><code class="p">.</code><code class="nx">forRoot</code><code class="p">(</code><code class="nx">appRoutes</code><code class="p">),</code>
  <code class="p">],</code>
  <code class="nx">exports</code><code class="o">:</code> <code class="p">[</code>
    <code class="nx">RouterModule</code>
  <code class="p">],</code>
<code class="p">})</code>
<code class="kr">export</code> <code class="kr">class</code> <code class="nx">AppRoutesModule</code> <code class="p">{</code> <code class="p">}</code></pre>

<p>The major change is again only restricted to the <code>appRoutes</code> array. Previously, we defined all our routes in this one file. Now, we use the <code>loadChildren</code> key to tell Angular that these routes are defined as part of a child module. This also means that our login and register routes have changed from <code>/login</code> to <code>/user/login</code> and so on, and similar for the stock routes. Make sure you make a pass through the entire application to fix all the routes changed, in particular the following files:</p>

<ul>
<li>
<p><em>register.component.ts</em> to redirect after registering</p>
</li>
<li>
<p><em>login.component.ts</em> to redirect after login</p>
</li>
<li>
<p><em>app.component.html</em> to fix all the navigation links</p>
</li>
</ul>

<p>Now, we can run our application (after making sure you start the Node.js server and proxy to it). When you run it, open up the network inspector of your browser, and see the requests getting made. Create/register a user, and then try logging in. Now if you have the network inspector open, you should see something like <a data-type="xref" href="#fig1202">Figure 12-2</a>.</p>

<figure><div id="fig1202" class="figure">
<img src="images/auar_12in02.png" alt="Lazy Loading a route" />
<h6><span class="label">Figure 12-2. </span>Angular lazy loading at work</h6>
</div></figure>

<p>Notice the additional request to load <em>stock.module.chunk.js</em> when a login happens. This is lazy loading the <code>StockModule</code> chunk once we log in.</p>

<p>You could extend this and configure it to your liking. You might choose to lazy load only the <code>StockModule</code>, and always load the <code>UserModule</code>, or vice versa. It just adds one more item in your toolbox to use to your liking.</p>

<p>The finished example that we created is available in the <em>chapter12/lazy-loading</em> folder in the GitHub repository.</p>

<p>Lazy loading can really impact performance and speed up the initial load for a very large application with lots of routes and code flows. It also makes a lot of sense when there are routes you know most users will not load or open. And as we saw, it is pretty straightforward to implement and add to your application.<a data-type="indexterm" data-primary="routing" data-secondary="in lazy loading applications" data-startref="ix_rtelzy" id="idm139828108492064"></a><a data-type="indexterm" data-primary="productionizing Angular apps" data-secondary="lazy loading" data-startref="ix_prodlzy" id="idm139828108490752"></a><a data-type="indexterm" data-primary="lazy loading" data-startref="ix_lzyld" id="idm139828108489520"></a></p>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Server-Side Rendering and Handling SEO"><div class="sect2" id="idm139828109107008">
<h2>Server-Side Rendering and Handling SEO</h2>

<p>We will look at one last thing in terms of performance before we wrap up this section.<a data-type="indexterm" data-primary="server-side rendering and handling SEO" id="ix_serside"></a><a data-type="indexterm" data-primary="productionizing Angular apps" data-secondary="server-side rendering and handling SEO" id="ix_prodser"></a> If we consider the life of the first request when we load any Angular (or any Single-Page Application in general) app in our browser, it looks something like this:</p>
<ol>
<li>
<p>A request is made with the base path to the server (say <em>www.mytestpage.com</em>).</p>
</li>
<li>
<p>The server serves the <em>index.html</em> file for that path.</p>
</li>
<li>
<p>The browser starts loading the <em>index.html</em>, and then for every static file it needs (CSS, JS, etc.), it will make another request to the server for them.</p>
</li>
<li>
<p>Once all the content has been loaded, Angular will bootstrap, parse the route, and load the necessary components.</p>
</li>
<li>
<p>The components will then make necessary server calls to fetch the data, and then render them.</p>
</li>

</ol>

<p>It is only at this point that the final view is rendered to the user. As you can see, there are multiple hops back-and-forth between the client and the server before this view is rendered. Of course, for future routes and navigation, it is only the component and its calls that happen, so the first few hops are skipped in a Single-Page Application for further routes.</p>

<p>This back-and-forth nature also makes it difficult to handle when it comes to search engine optimization,<a data-type="indexterm" data-primary="search engine optimization (SEO)" id="ix_SEO"></a> as most search engine crawlers will not actually render and execute JavaScript when they try to crawl web pages (for various security reasons). Thus, more often than not, deep links and routes in a Single-Page Application also do not get indexed properly.<a data-type="indexterm" data-primary="Pre-render" id="idm139828108475328"></a> One option to solve this is to use something like <a href="https://github.com/prerender/prerender">Pre-render</a>, which can render the web application in PhantomJS on the server, and serve the fully rendered HTML for search engines to index.</p>

<p>But with Angular, there is another option: rendering the application server-side. We accomplish this using something known as <a href="https://angular.io/guide/universal#angular-universal-server-side-rendering">Angular Universal</a>.<a data-type="indexterm" data-primary="Angular Universal" id="idm139828108472496"></a> With this approach, we render the Angular application for serving the initial request on the server itself, and then let Angular bootstrap and take over for the remaining application on the client-side. Thus, we get the best of both worlds, where the initial request does not have the usual back-and-forth, and future requests behave like a Single-Page Application. It also helps in reducing the perceived latency, as the user immediately gets the information he needs while the remaining libraries and framework load.</p>

<p>In this section, we won’t go too much into the details of exactly how Angular accomplishes this, but rather focus on what it takes for us to integrate and get it working. Let’s see how we might take the Angular application we have been working on so far and make it into an Angular Universal application that can seamlessly run on both client and server.</p>
<div data-type="warning" epub:type="warning"><h6>Warning</h6>
<p>Angular Universal is in its infancy, so expect to face lots of trouble as you go about integrating it, especially when it comes to working with third-party libraries and components.<a data-type="indexterm" data-primary="Angular Universal" data-secondary="caveats" id="idm139828108267984"></a> Even the online guides and tutorials will often be out-of-date, incomplete, or not working as the work is still in progress and prone to sudden changes.</p>
</div>

<p>We will again use the codebase from <em>chapter11/routing-guard</em> as the base, and add server-side rendering capability to it. There are fundamentally five new files we will need to add to get <a data-type="indexterm" data-primary="Angular Universal" data-secondary="files needed to make it work" id="idm139828108265632"></a>Angular Universal working:</p>

<ul>
<li>
<p>A bootstrapper for the server app (<em>main.server.ts</em>)</p>
</li>
<li>
<p>TypeScript configuration for our server (<em>tsconfig.server.json</em>)</p>
</li>
<li>
<p>An application module for our server-side app (<em>app.server.module.ts</em>)</p>
</li>
<li>
<p>An express web server to serve our application code (<em>server.ts</em>)</p>
</li>
<li>
<p>Webpack server configuration to define how the build happens (<em>webpack.server.config.js</em>)</p>
</li>
</ul>

<p>In addition, we will be making changes to a few other files as we go along.</p>










<section data-type="sect3" data-pdf-bookmark="Dependencies"><div class="sect3" id="idm139828108256704">
<h3>Dependencies</h3>

<p>To get started, we will rely on a few Angular platform libraries and frameworks.<a data-type="indexterm" data-primary="server-side rendering and handling SEO" data-secondary="dependencies" id="idm139828108255136"></a><a data-type="indexterm" data-primary="dependencies" data-secondary="for server-side rendering and SEO" id="idm139828108254144"></a><a data-type="indexterm" data-primary="productionizing Angular apps" data-secondary="server-side rendering and handling SEO" data-tertiary="dependencies" id="idm139828108253184"></a> We will need to install the following <code>npm</code> packages:</p>
<dl>
<dt>@angular/platform-server</dt>
<dd>
<p>These provide the Angular server-side components to run and render our application code on the server.</p>
</dd>
<dt>@nguniversal/module-map-ngfactory-loader</dt>
<dd>
<p>In case we use lazy loading for routes, we use the factory loader to lazy load routes in the context of a server-side render.</p>
</dd>
<dt>@nguniversal/express-engine</dt>
<dd>
<p>An express engine to integrate with Angular Universal and render our application.</p>
</dd>
<dt>ts-loader</dt>
<dd>
<p>TypeScript loader to transpile <a data-type="indexterm" data-primary="ts-loader" id="idm139828108245376"></a>our server-side application into JavaScript and run it using Node.js.</p>
</dd>
</dl>

<p>You can install all of these using the following command:</p>
<pre data-type="programlisting">
<strong>npm install --save @angular/platform-server
                   @nguniversal/module-map-ngfactory-loader</strong>
<strong>                   ts-loader@3.5.0 @nguniversal/express-engine</strong>
</pre>

<p>This will install and save all of these dependencies to your <em>package.json</em>. Note that we have installed a specific version of the <code>ts-loader</code>, because of a <a href="https://github.com/angular/angular-cli/issues/9783">bug</a> with the library and how it interacts with our Angular Universal application.</p>
</div></section>













<section data-type="sect3" data-pdf-bookmark="Making the changes"><div class="sect3" id="idm139828108239936">
<h3>Making the changes</h3>

<p>The first thing we will do is modify the <code>AppModule</code> to have the capability to hook into a rendered server-side Angular application.<a data-type="indexterm" data-primary="server-side rendering and handling SEO" data-secondary="making changes to the code" id="idm139828108237696"></a><a data-type="indexterm" data-primary="productionizing Angular apps" data-secondary="server-side rendering and handling SEO" data-tertiary="making changes to the code" id="idm139828108236736"></a> We accomplish this by replacing the <code>BrowserModule</code> import in <em>src/app/app.module.ts</em> with the following line:</p>

<pre data-type="programlisting" data-code-language="ts"><code class="nx">BrowserModule</code><code class="p">.</code><code class="nx">withServerTransition</code><code class="p">({</code> <code class="nx">appId</code><code class="o">:</code> <code class="s1">'stock-app'</code> <code class="p">}),</code></pre>

<p>The <code>appId</code> is just for reference and a keyword for Angular to use when it renders server-side styles and the like. You can replace it with anything of your choice. We can also get runtime information about the current platform (whether Angular is running on the server or the client) and the <code>appId</code> through Angular as well. We can add the following constructor to the <code>AppModule</code>:</p>

<pre data-type="programlisting" data-code-language="ts"><code class="kr">import</code> <code class="p">{</code> <code class="nx">NgModule</code><code class="p">,</code> <code class="nx">Inject</code><code class="p">,</code> <code class="nx">PLATFORM_ID</code><code class="p">,</code> <code class="nx">APP_ID</code> <code class="p">}</code> <code class="nx">from</code> <code class="s1">'@angular/core'</code><code class="p">;</code>
<code class="kr">import</code> <code class="p">{</code> <code class="nx">isPlatformBrowser</code><code class="p">,</code> <code class="nx">APP_BASE_HREF</code> <code class="p">}</code> <code class="nx">from</code> <code class="s1">'@angular/common'</code><code class="p">;</code>

<code class="err">@</code><code class="nx">NgModule</code><code class="p">({</code>
<code class="cm">/** Skipped for brevity */</code>
  <code class="nx">providers</code><code class="o">:</code> <code class="p">[</code>
     <code class="cm">/* Skipping common ones for brevity */</code>
     <code class="p">{</code><code class="nx">provide</code>: <code class="kt">APP_BASE_HREF</code><code class="p">,</code> <code class="nx">useValue</code><code class="o">:</code> <code class="s1">''</code><code class="p">}</code>
  <code class="p">]</code>
<code class="p">})</code>
<code class="kr">export</code> <code class="kr">class</code> <code class="nx">AppModule</code> <code class="p">{</code>

 <code class="kr">constructor</code><code class="p">(</code>
     <code class="err">@</code><code class="nx">Inject</code><code class="p">(</code><code class="nx">PLATFORM_ID</code><code class="p">)</code> <code class="kr">private</code> <code class="nx">platformId</code>: <code class="kt">Object</code><code class="p">,</code>
     <code class="err">@</code><code class="nx">Inject</code><code class="p">(</code><code class="nx">APP_ID</code><code class="p">)</code> <code class="kr">private</code> <code class="nx">appId</code>: <code class="kt">string</code><code class="p">)</code> <code class="p">{</code>
   <code class="kr">const</code> <code class="nx">platform</code> <code class="o">=</code> <code class="nx">isPlatformBrowser</code><code class="p">(</code><code class="nx">platformId</code><code class="p">)</code> <code class="o">?</code>
       <code class="s1">'in the browser'</code> <code class="o">:</code> <code class="s1">'on the server'</code><code class="p">;</code>
   <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="err">`</code><code class="nx">Running</code> <code class="nx">$</code><code class="p">{</code><code class="nx">platform</code><code class="p">}</code> <code class="kd">with</code> <code class="nx">appId</code><code class="o">=</code><code class="nx">$</code><code class="p">{</code><code class="nx">appId</code><code class="p">}</code><code class="err">`</code><code class="p">);</code>
 <code class="p">}</code>
<code class="p">}</code></pre>

<p><code>isPlatformBrowser</code> is a useful check that you can use in other contexts as well, to selectively enable/disable certain flows and features in your application. <a data-type="indexterm" data-primary="isPlatformBrowser" id="idm139828108216496"></a>There might be preloading, caching, and other flows you might want to keep only for the browser, and you can use <code>isPlatformBrowser</code> for this.</p>

<p>The next major change is to the URLs to which we make HTTP calls. In the browser, relative URLs are fine. But in a Universal app, especially on the server side, the HTTP URLs must be absolute for Angular Universal to be able to resolve them correctly. One trick (which we will do here) is to use the <code>APP_BASE_HREF</code> token, which we can inject into our services. In the context of our browser, this will be what we have defined it to be, and in the server, it will have the entire URL. Another way to do it might be to again use <code>isPlatformBrowser</code> to check and change the URL. So in our browser-specific flow, we set the value of <code>APP_BASE_HREF</code> in the main module to be an empty string.<a data-type="indexterm" data-primary="APP_BASE_HREF, setting value" id="idm139828108067952"></a></p>

<p>We will use the <code>APP_BASE_HREF</code> trick in the <em>stock.service.ts</em> file as follows:</p>

<pre data-type="programlisting" data-code-language="ts"><code class="kr">import</code> <code class="p">{</code> <code class="nx">Injectable</code><code class="p">,</code> <code class="nx">Optional</code><code class="p">,</code> <code class="nx">Inject</code> <code class="p">}</code> <code class="nx">from</code> <code class="s1">'@angular/core'</code><code class="p">;</code>
<code class="kr">import</code> <code class="p">{</code> <code class="nx">APP_BASE_HREF</code> <code class="p">}</code> <code class="nx">from</code> <code class="s1">'@angular/common'</code><code class="p">;</code>

<code class="cm">/** Remaining imports skipped for brevity */</code>

<code class="err">@</code><code class="nx">Injectable</code><code class="p">()</code>
<code class="kr">export</code> <code class="kr">class</code> <code class="nx">StockService</code> <code class="p">{</code>

  <code class="kr">private</code> <code class="nx">baseUrl</code>: <code class="kt">string</code><code class="p">;</code>

  <code class="kr">constructor</code><code class="p">(</code><code class="kr">private</code> <code class="nx">http</code>: <code class="kt">HttpClient</code><code class="p">,</code>
              <code class="kr">private</code> <code class="nx">userStore</code>: <code class="kt">UserStoreService</code><code class="p">,</code>
              <code class="err">@</code><code class="nx">Optional</code><code class="p">()</code> <code class="err">@</code><code class="nx">Inject</code><code class="p">(</code><code class="nx">APP_BASE_HREF</code><code class="p">)</code> <code class="nx">origin</code>: <code class="kt">string</code><code class="p">)</code> <code class="p">{</code>
    <code class="k">this</code><code class="p">.</code><code class="nx">baseUrl</code> <code class="o">=</code> <code class="err">`</code><code class="nx">$</code><code class="p">{</code><code class="nx">origin</code><code class="p">}</code><code class="o">/</code><code class="nx">api</code><code class="o">/</code><code class="nx">stock</code><code class="err">`</code><code class="p">;</code>
  <code class="p">}</code>

  <code class="nx">getStocks</code><code class="p">()</code> <code class="o">:</code> <code class="nx">Observable</code><code class="o">&lt;</code><code class="nx">Stock</code><code class="p">[]</code><code class="o">&gt;</code> <code class="p">{</code>
    <code class="k">return</code> <code class="k">this</code><code class="p">.</code><code class="nx">http</code><code class="p">.</code><code class="nx">get</code><code class="o">&lt;</code><code class="nx">Stock</code><code class="p">[]</code><code class="o">&gt;</code><code class="p">(</code><code class="k">this</code><code class="p">.</code><code class="nx">baseUrl</code><code class="p">);</code>
  <code class="p">}</code>

  <code class="cm">/** Remaining skipped for brevity */</code>
<code class="p">}</code></pre>

<p>We would make the same change in the <em>user.service.ts</em> file as well, which we are skipping for brevity. You can always look up the changes in the finished example if you are unsure.</p>
</div></section>













<section data-type="sect3" data-pdf-bookmark="Additions for the server side"><div class="sect3" id="idm139828108239312">
<h3>Additions for the server side</h3>

<p>Next, we will look at some of the additions we need to do on the server side for the application to actually run.<a data-type="indexterm" data-primary="server-side rendering and handling SEO" data-secondary="additions for the server side" id="idm139828107855920"></a><a data-type="indexterm" data-primary="productionizing Angular apps" data-secondary="server-side rendering and handling SEO" data-tertiary="additions for the server side" id="idm139828107855008"></a> We will first start with a parallel <code>AppServerModule</code> (created as <em>src/app/app.server.module.ts</em>) to the <code>AppModule</code>, which will be used by the server:</p>

<pre data-type="programlisting" data-code-language="ts"><code class="kr">import</code> <code class="p">{</code> <code class="nx">NgModule</code> <code class="p">}</code> <code class="nx">from</code> <code class="s1">'@angular/core'</code><code class="p">;</code>
<code class="kr">import</code> <code class="p">{</code> <code class="nx">ServerModule</code> <code class="p">}</code> <code class="nx">from</code> <code class="s1">'@angular/platform-server'</code><code class="p">;</code>
<code class="kr">import</code> <code class="p">{</code> <code class="nx">ModuleMapLoaderModule</code> <code class="p">}</code> <code class="nx">from</code> <code class="s1">'@nguniversal/module-map-ngfactory-loader'</code><code class="p">;</code>

<code class="kr">import</code> <code class="p">{</code> <code class="nx">AppModule</code> <code class="p">}</code> <code class="nx">from</code> <code class="s1">'./app.module'</code><code class="p">;</code>
<code class="kr">import</code> <code class="p">{</code> <code class="nx">AppComponent</code> <code class="p">}</code> <code class="nx">from</code> <code class="s1">'./app.component'</code><code class="p">;</code>
<code class="kr">import</code> <code class="p">{</code> <code class="nx">APP_BASE_HREF</code> <code class="p">}</code> <code class="nx">from</code> <code class="s1">'@angular/common'</code><code class="p">;</code>

<code class="err">@</code><code class="nx">NgModule</code><code class="p">({</code>
  <code class="nx">imports</code><code class="o">:</code> <code class="p">[</code>
    <code class="nx">AppModule</code><code class="p">,</code>
    <code class="nx">ServerModule</code><code class="p">,</code>
    <code class="nx">ModuleMapLoaderModule</code>
  <code class="p">],</code>
  <code class="nx">providers</code><code class="o">:</code> <code class="p">[</code>
    <code class="c1">// Add universal-only providers here</code>
    <code class="p">{</code><code class="nx">provide</code>: <code class="kt">APP_BASE_HREF</code><code class="p">,</code> <code class="nx">useValue</code><code class="o">:</code> <code class="s1">'http://localhost:4000/'</code><code class="p">}</code>
  <code class="p">],</code>
  <code class="nx">bootstrap</code><code class="o">:</code> <code class="p">[</code> <code class="nx">AppComponent</code> <code class="p">],</code>
<code class="p">})</code>
<code class="kr">export</code> <code class="kr">class</code> <code class="nx">AppServerModule</code> <code class="p">{}</code></pre>

<p>Notice that we import the original <code>AppModule</code> into our <code>AppServerModule</code>, and then add the <code>ServerModule</code> from Angular along with the <code>ModuleMapLoaderModule</code> to handle any lazy-loaded routes.<a data-type="indexterm" data-primary="routing" data-secondary="in lazy loading applications" id="idm139828107952544"></a> We still bootstrap the <code>AppComponent</code>. We would set up any Universal-specific providers in the <code>providers</code> section, which would be for services that are only server-specific.<a data-type="indexterm" data-primary="providers" data-secondary="Universal-specific" id="idm139828107950624"></a> In this case, we ensure that the value of <code>APP_BASE_HREF</code> is provided with an absolute path so that our server can actually make the correct requests.<a data-type="indexterm" data-primary="APP_BASE_HREF, setting value" id="idm139828107948960"></a></p>

<p>We would also create a parallel <em>main.server.ts</em> that will be responsible as the entry point<a data-type="indexterm" data-primary="main.server.ts file" id="idm139828107947456"></a> for our server-side Angular application, which would be very straightforward. Create it as <em>src/main.server.ts</em> with the following content:</p>

<pre data-type="programlisting" data-code-language="ts"><code class="kr">export</code> <code class="p">{</code> <code class="nx">AppServerModule</code> <code class="p">}</code> <code class="nx">from</code> <code class="s1">'./app/app.server.module'</code><code class="p">;</code></pre>

<p>Now we are ready to create our server. For the purpose of this example, we will use a Node.js express server, for which Angular Universal has out-of-the-box integration support. It is not necessary to understand the depths of this server code.<a data-type="indexterm" data-primary="server.ts file" id="idm139828107943328"></a> Create a <em>server.ts</em> file in the main root folder of the application with the following content:</p>

<pre data-type="programlisting" data-code-language="ts"><code class="c1">// These are important and needed before anything else</code>
<code class="kr">import</code> <code class="s1">'zone.js/dist/zone-node'</code><code class="p">;</code>
<code class="kr">import</code> <code class="s1">'reflect-metadata'</code><code class="p">;</code>

<code class="kr">import</code> <code class="p">{</code> <code class="nx">enableProdMode</code> <code class="p">}</code> <code class="nx">from</code> <code class="s1">'@angular/core'</code><code class="p">;</code>

<code class="kr">import</code> <code class="o">*</code> <code class="kr">as</code> <code class="nx">express</code> <code class="nx">from</code> <code class="s1">'express'</code><code class="p">;</code>
<code class="kr">import</code> <code class="p">{</code> <code class="nx">join</code> <code class="p">}</code> <code class="nx">from</code> <code class="s1">'path'</code><code class="p">;</code>

<code class="kr">import</code> <code class="o">*</code> <code class="kr">as</code> <code class="nx">proxy</code> <code class="nx">from</code> <code class="s1">'http-proxy-middleware'</code><code class="p">;</code>


<code class="c1">// Faster server renders w/ Prod mode (dev mode never needed)</code>
<code class="nx">enableProdMode</code><code class="p">();</code>


<code class="c1">// Express server</code>
<code class="kr">const</code> <code class="nx">app</code> <code class="o">=</code> <code class="nx">express</code><code class="p">();</code>

<code class="kr">const</code> <code class="nx">PORT</code> <code class="o">=</code> <code class="nx">process</code><code class="p">.</code><code class="nx">env</code><code class="p">.</code><code class="nx">PORT</code> <code class="o">||</code> <code class="mi">4000</code><code class="p">;</code>
<code class="kr">const</code> <code class="nx">DIST_FOLDER</code> <code class="o">=</code> <code class="nx">join</code><code class="p">(</code><code class="nx">process</code><code class="p">.</code><code class="nx">cwd</code><code class="p">(),</code> <code class="s1">'dist'</code><code class="p">);</code>

<code class="c1">// * NOTE :: leave this as require() since this file</code>
<code class="c1">// is built Dynamically from webpack</code>
<code class="kr">const</code> <code class="p">{</code> <code class="nx">AppServerModuleNgFactory</code><code class="p">,</code> <code class="nx">LAZY_MODULE_MAP</code> <code class="p">}</code> <code class="o">=</code>
    <code class="nx">require</code><code class="p">(</code><code class="s1">'./dist/server/main.bundle'</code><code class="p">);</code>

<code class="c1">// Express Engine</code>
<code class="kr">import</code> <code class="p">{</code> <code class="nx">ngExpressEngine</code> <code class="p">}</code> <code class="nx">from</code> <code class="s1">'@nguniversal/express-engine'</code><code class="p">;</code>
<code class="c1">// Import module map for lazy loading</code>
<code class="kr">import</code> <code class="p">{</code> <code class="nx">provideModuleMap</code> <code class="p">}</code> <code class="nx">from</code> <code class="s1">'@nguniversal/module-map-ngfactory-loader'</code><code class="p">;</code>

<code class="nx">app</code><code class="p">.</code><code class="nx">engine</code><code class="p">(</code><code class="s1">'html'</code><code class="p">,</code> <code class="nx">ngExpressEngine</code><code class="p">({</code>
  <code class="nx">bootstrap</code>: <code class="kt">AppServerModuleNgFactory</code><code class="p">,</code>
  <code class="nx">providers</code><code class="o">:</code> <code class="p">[</code>
    <code class="nx">provideModuleMap</code><code class="p">(</code><code class="nx">LAZY_MODULE_MAP</code><code class="p">)</code>
  <code class="p">]</code>
<code class="p">}));</code>

<code class="nx">app</code><code class="p">.</code><code class="nx">set</code><code class="p">(</code><code class="s1">'view engine'</code><code class="p">,</code> <code class="s1">'html'</code><code class="p">);</code>
<code class="nx">app</code><code class="p">.</code><code class="nx">set</code><code class="p">(</code><code class="s1">'views'</code><code class="p">,</code> <code class="nx">join</code><code class="p">(</code><code class="nx">DIST_FOLDER</code><code class="p">,</code> <code class="s1">'browser'</code><code class="p">));</code>

<code class="nx">app</code><code class="p">.</code><code class="nx">use</code><code class="p">(</code><code class="s1">'/api'</code><code class="p">,</code> <code class="nx">proxy</code><code class="p">({</code>
  <code class="nx">target</code><code class="o">:</code> <code class="s1">'http://localhost:3000'</code><code class="p">,</code>
  <code class="nx">changeOrigin</code>: <code class="kt">true</code>
<code class="p">}));</code>


<code class="c1">// Server static files from /browser</code>
<code class="nx">app</code><code class="p">.</code><code class="nx">get</code><code class="p">(</code><code class="s1">'*.*'</code><code class="p">,</code> <code class="nx">express</code><code class="p">.</code><code class="kr">static</code><code class="p">(</code><code class="nx">join</code><code class="p">(</code><code class="nx">DIST_FOLDER</code><code class="p">,</code> <code class="s1">'browser'</code><code class="p">)));</code>

<code class="c1">// All regular routes use the Universal engine</code>
<code class="nx">app</code><code class="p">.</code><code class="nx">get</code><code class="p">(</code><code class="s1">'*'</code><code class="p">,</code> <code class="p">(</code><code class="nx">req</code><code class="p">,</code> <code class="nx">res</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">{</code>
  <code class="nx">res</code><code class="p">.</code><code class="nx">render</code><code class="p">(</code><code class="nx">join</code><code class="p">(</code><code class="nx">DIST_FOLDER</code><code class="p">,</code> <code class="s1">'browser'</code><code class="p">,</code> <code class="s1">'index.html'</code><code class="p">),</code> <code class="p">{</code> <code class="nx">req</code> <code class="p">});</code>
<code class="p">});</code>

<code class="c1">// Start up the Node server</code>
<code class="nx">app</code><code class="p">.</code><code class="nx">listen</code><code class="p">(</code><code class="nx">PORT</code><code class="p">,</code> <code class="p">()</code> <code class="o">=&gt;</code> <code class="p">{</code>
  <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="err">`</code><code class="nx">Node</code> <code class="nx">server</code> <code class="nx">listening</code> <code class="nx">on</code> <code class="nx">http</code><code class="o">:</code><code class="c1">//localhost:${PORT}`);</code>
<code class="p">});</code></pre>

<p>The preceding server is a very simplistic, insecure web server that serves your Angular application, but after rendering it on the server side. Again, <em>add your security and authorization checks</em> before you take it to production.</p>

<p class="pagebreak-before">We make a few assumptions so that the whole process is easier for us. Primarily:</p>

<ul>
<li>
<p>The server uses the <code>ngExpressEngine</code> to convert all client requests into a server-rendered page.<a data-type="indexterm" data-primary="ngExpressEngine" id="idm139828108012064"></a> We pass it the <code>AppServerModule</code> that we wrote, which acts as the bridge between the server-side rendered application and our web application.</p>
</li>
<li>
<p>We need to figure out what requests are for data, which are for static files, and which are Angular routes.</p>
</li>
<li>
<p>We expect all <em>/api/*</em> routes to be API/data routes, and the work to handle that if left incomplete.</p>
</li>
<li>
<p>We also expect that any request with an extension (say, <em>.js</em> or <em>.css</em>) will be for a static file, and serve that as a static file from a predefined folder.</p>
</li>
<li>
<p>Finally, any request without an extension is then treated as an Angular route, and uses the <code>ngExpressEngine</code> to render the Angular server-side rendered page.</p>
</li>
</ul>
</div></section>













<section data-type="sect3" data-pdf-bookmark="Configuration"><div class="sect3" id="idm139828107857056">
<h3>Configuration</h3>

<p>Finally, we get to the configuration that pulls all of these together.<a data-type="indexterm" data-primary="server-side rendering and handling SEO" data-secondary="configuration" id="idm139828107525872"></a><a data-type="indexterm" data-primary="productionizing Angular apps" data-secondary="server-side rendering and handling SEO" data-tertiary="configuration" id="idm139828107524880"></a> The first thing is to write a configuration for TypeScript, which<a data-type="indexterm" data-primary="TypeScript" data-secondary="tsconfig.server.json file" id="idm139828107523504"></a> we can add as <em>src/tsconfig.server.json</em> with the following content:</p>

<pre data-type="programlisting" data-code-language="json"><code class="p">{</code>
  <code class="nt">"extends"</code><code class="p">:</code> <code class="s2">"../tsconfig.json"</code><code class="p">,</code>
  <code class="nt">"compilerOptions"</code><code class="p">:</code> <code class="p">{</code>
    <code class="nt">"outDir"</code><code class="p">:</code> <code class="s2">"../out-tsc/app"</code><code class="p">,</code>
    <code class="nt">"baseUrl"</code><code class="p">:</code> <code class="s2">"./"</code><code class="p">,</code>
    <code class="nt">"module"</code><code class="p">:</code> <code class="s2">"commonjs"</code><code class="p">,</code>
    <code class="nt">"types"</code><code class="p">:</code> <code class="p">[]</code>
  <code class="p">},</code>
  <code class="nt">"exclude"</code><code class="p">:</code> <code class="p">[</code>
    <code class="s2">"test.ts"</code><code class="p">,</code>
    <code class="s2">"**/*.spec.ts"</code>
  <code class="p">],</code>
  <code class="nt">"angularCompilerOptions"</code><code class="p">:</code> <code class="p">{</code>
    <code class="nt">"entryModule"</code><code class="p">:</code> <code class="s2">"app/app.server.module#AppServerModule"</code>
  <code class="p">}</code>
<code class="p">}</code></pre>

<p>We extend the existing <em>tsconfig.json</em>, and point it to our new <code>AppServerModule</code> as the entry module. Also, the module <em>must</em> be set to <code>commonjs</code> for the Angular Universal application to work.</p>

<p>Next, we need the Webpack configuration for our server<a data-type="indexterm" data-primary="webpack.server.config.js file" id="idm139828107317904"></a> to compile and work. We add it as <em>webpack.server.config.js</em> at the root folder level, with the following content:</p>

<pre data-type="programlisting" data-code-language="ts"><code class="kr">const</code> <code class="nx">path</code> <code class="o">=</code> <code class="nx">require</code><code class="p">(</code><code class="s1">'path'</code><code class="p">);</code>
<code class="kr">const</code> <code class="nx">webpack</code> <code class="o">=</code> <code class="nx">require</code><code class="p">(</code><code class="s1">'webpack'</code><code class="p">);</code>

<code class="kr">module</code><code class="nx">.exports</code> <code class="o">=</code> <code class="p">{</code>
  <code class="nx">entry</code><code class="o">:</code> <code class="p">{</code> <code class="nx">server</code><code class="o">:</code> <code class="s1">'./server.ts'</code> <code class="p">},</code>
  <code class="nx">resolve</code><code class="o">:</code> <code class="p">{</code> <code class="nx">extensions</code><code class="o">:</code> <code class="p">[</code><code class="s1">'.js'</code><code class="p">,</code> <code class="s1">'.ts'</code><code class="p">]</code> <code class="p">},</code>
  <code class="nx">target</code><code class="o">:</code> <code class="s1">'node'</code><code class="p">,</code>
  <code class="c1">// this makes sure we include node_modules and other third-party libraries</code>
  <code class="nx">externals</code><code class="o">:</code> <code class="p">[</code><code class="sr">/(node_modules|main\..*\.js)/</code><code class="p">],</code>
  <code class="nx">output</code><code class="o">:</code> <code class="p">{</code>
    <code class="nx">path</code>: <code class="kt">path.join</code><code class="p">(</code><code class="nx">__dirname</code><code class="p">,</code> <code class="s1">'dist'</code><code class="p">),</code>
    <code class="nx">filename</code><code class="o">:</code> <code class="s1">'[name].js'</code>
  <code class="p">},</code>
  <code class="nx">module</code><code class="o">:</code> <code class="p">{</code>
    <code class="nx">rules</code><code class="o">:</code> <code class="p">[{</code> <code class="nx">test</code><code class="o">:</code> <code class="sr">/\.ts$/</code><code class="p">,</code> <code class="nx">loader</code><code class="o">:</code> <code class="s1">'ts-loader'</code> <code class="p">}]</code>
  <code class="p">},</code>
  <code class="nx">plugins</code><code class="o">:</code> <code class="p">[</code>
    <code class="k">new</code> <code class="nx">webpack</code><code class="p">.</code><code class="nx">ContextReplacementPlugin</code><code class="p">(</code>
      <code class="sr">/(.+)?angular(\\|\/)core(.+)?/</code><code class="p">,</code>
      <code class="nx">path</code><code class="p">.</code><code class="nx">join</code><code class="p">(</code><code class="nx">__dirname</code><code class="p">,</code> <code class="s1">'src'</code><code class="p">),</code> <code class="c1">// location of your src</code>
      <code class="p">{}</code> <code class="c1">// a map of your routes</code>
    <code class="p">),</code>
    <code class="k">new</code> <code class="nx">webpack</code><code class="p">.</code><code class="nx">ContextReplacementPlugin</code><code class="p">(</code>
      <code class="sr">/(.+)?express(\\|\/)(.+)?/</code><code class="p">,</code>
      <code class="nx">path</code><code class="p">.</code><code class="nx">join</code><code class="p">(</code><code class="nx">__dirname</code><code class="p">,</code> <code class="s1">'src'</code><code class="p">),</code>
      <code class="p">{}</code>
    <code class="p">)</code>
  <code class="p">]</code>
<code class="p">};</code></pre>

<p>This is mainly so that our Node.js <em>server.ts</em> compiles into executable JavaScript code, with some fixes for some bugs in the Angular CLI. It also hooks up the <code>ts-loader</code> plug-in we installed so that it can convert our TypeScript into JavaScript correctly.<a data-type="indexterm" data-primary="ts-loader" id="idm139828107314080"></a></p>

<p>We also need to make a small change to the Angular CLI configuration JSON file (<em>.angular-cli.json</em>) to make sure it outputs our application code correctly based on the platform.<a data-type="indexterm" data-primary="command-line interface (CLI)" data-secondary="Angular CLI configuration JSON file" id="idm139828107150752"></a> Add the following configuration as another entry into the <code>apps</code> array:</p>

<pre data-type="programlisting" data-code-language="js"><code class="p">{</code>
  <code class="s2">"platform"</code><code class="o">:</code> <code class="s2">"server"</code><code class="p">,</code>
  <code class="s2">"root"</code><code class="o">:</code> <code class="s2">"src"</code><code class="p">,</code>
  <code class="s2">"outDir"</code><code class="o">:</code> <code class="s2">"dist/server"</code><code class="p">,</code>
  <code class="s2">"assets"</code><code class="o">:</code> <code class="p">[],</code>
  <code class="s2">"index"</code><code class="o">:</code> <code class="s2">"index.html"</code><code class="p">,</code>
  <code class="s2">"main"</code><code class="o">:</code> <code class="s2">"main.server.ts"</code><code class="p">,</code>
  <code class="s2">"polyfills"</code><code class="o">:</code> <code class="s2">"polyfills.ts"</code><code class="p">,</code>
  <code class="s2">"test"</code><code class="o">:</code> <code class="s2">"test.ts"</code><code class="p">,</code>
  <code class="s2">"tsconfig"</code><code class="o">:</code> <code class="s2">"tsconfig.server.json"</code><code class="p">,</code>
  <code class="s2">"testTsconfig"</code><code class="o">:</code> <code class="s2">"tsconfig.spec.json"</code><code class="p">,</code>
  <code class="s2">"prefix"</code><code class="o">:</code> <code class="s2">"app"</code><code class="p">,</code>
  <code class="s2">"styles"</code><code class="o">:</code> <code class="p">[</code>
    <code class="s2">"styles.css"</code>
  <code class="p">],</code>
  <code class="s2">"scripts"</code><code class="o">:</code> <code class="p">[],</code>
  <code class="s2">"environmentSource"</code><code class="o">:</code> <code class="s2">"environments/environment.ts"</code><code class="p">,</code>
  <code class="s2">"environments"</code><code class="o">:</code> <code class="p">{</code>
    <code class="s2">"dev"</code><code class="o">:</code> <code class="s2">"environments/environment.ts"</code><code class="p">,</code>
    <code class="s2">"prod"</code><code class="o">:</code> <code class="s2">"environments/environment.prod.ts"</code>
  <code class="p">}</code>
<code class="p">}</code></pre>

<p>While you are at it, also change the existing entry and change the <code>outDir</code> from <code>dist</code> to <code>dist/browser</code>. Your combined <code>apps</code> array in <em>.angular-cli.json</em> should look something like this:</p>

<pre data-type="programlisting" data-code-language="json"><code class="s2">"apps"</code><code class="err">:</code> <code class="p">[</code>
    <code class="p">{</code>
      <code class="nt">"root"</code><code class="p">:</code> <code class="s2">"src"</code><code class="p">,</code>
      <code class="nt">"outDir"</code><code class="p">:</code> <code class="s2">"dist/browser"</code><code class="p">,</code>
      <code class="nt">"assets"</code><code class="p">:</code> <code class="p">[</code>
        <code class="s2">"assets"</code><code class="p">,</code>
        <code class="s2">"favicon.ico"</code>
      <code class="p">],</code>
      <code class="nt">"index"</code><code class="p">:</code> <code class="s2">"index.html"</code><code class="p">,</code>
      <code class="nt">"main"</code><code class="p">:</code> <code class="s2">"main.ts"</code><code class="p">,</code>
      <code class="nt">"polyfills"</code><code class="p">:</code> <code class="s2">"polyfills.ts"</code><code class="p">,</code>
      <code class="nt">"test"</code><code class="p">:</code> <code class="s2">"test.ts"</code><code class="p">,</code>
      <code class="nt">"tsconfig"</code><code class="p">:</code> <code class="s2">"tsconfig.app.json"</code><code class="p">,</code>
      <code class="nt">"testTsconfig"</code><code class="p">:</code> <code class="s2">"tsconfig.spec.json"</code><code class="p">,</code>
      <code class="nt">"prefix"</code><code class="p">:</code> <code class="s2">"app"</code><code class="p">,</code>
      <code class="nt">"styles"</code><code class="p">:</code> <code class="p">[</code>
        <code class="s2">"styles.css"</code>
      <code class="p">],</code>
      <code class="nt">"scripts"</code><code class="p">:</code> <code class="p">[],</code>
      <code class="nt">"environmentSource"</code><code class="p">:</code> <code class="s2">"environments/environment.ts"</code><code class="p">,</code>
      <code class="nt">"environments"</code><code class="p">:</code> <code class="p">{</code>
        <code class="nt">"dev"</code><code class="p">:</code> <code class="s2">"environments/environment.ts"</code><code class="p">,</code>
        <code class="nt">"prod"</code><code class="p">:</code> <code class="s2">"environments/environment.prod.ts"</code>
      <code class="p">}</code>
    <code class="p">},</code> <code class="p">{</code>
      <code class="nt">"platform"</code><code class="p">:</code> <code class="s2">"server"</code><code class="p">,</code>
      <code class="nt">"root"</code><code class="p">:</code> <code class="s2">"src"</code><code class="p">,</code>
      <code class="nt">"outDir"</code><code class="p">:</code> <code class="s2">"dist/server"</code><code class="p">,</code>
      <code class="nt">"assets"</code><code class="p">:</code> <code class="p">[],</code>
      <code class="nt">"index"</code><code class="p">:</code> <code class="s2">"index.html"</code><code class="p">,</code>
      <code class="nt">"main"</code><code class="p">:</code> <code class="s2">"main.server.ts"</code><code class="p">,</code>
      <code class="nt">"polyfills"</code><code class="p">:</code> <code class="s2">"polyfills.ts"</code><code class="p">,</code>
      <code class="nt">"test"</code><code class="p">:</code> <code class="s2">"test.ts"</code><code class="p">,</code>
      <code class="nt">"tsconfig"</code><code class="p">:</code> <code class="s2">"tsconfig.server.json"</code><code class="p">,</code>
      <code class="nt">"testTsconfig"</code><code class="p">:</code> <code class="s2">"tsconfig.spec.json"</code><code class="p">,</code>
      <code class="nt">"prefix"</code><code class="p">:</code> <code class="s2">"app"</code><code class="p">,</code>
      <code class="nt">"styles"</code><code class="p">:</code> <code class="p">[</code>
        <code class="s2">"styles.css"</code>
      <code class="p">],</code>
      <code class="nt">"scripts"</code><code class="p">:</code> <code class="p">[],</code>
      <code class="nt">"environmentSource"</code><code class="p">:</code> <code class="s2">"environments/environment.ts"</code><code class="p">,</code>
      <code class="nt">"environments"</code><code class="p">:</code> <code class="p">{</code>
        <code class="nt">"dev"</code><code class="p">:</code> <code class="s2">"environments/environment.ts"</code><code class="p">,</code>
        <code class="nt">"prod"</code><code class="p">:</code> <code class="s2">"environments/environment.prod.ts"</code>
      <code class="p">}</code>
    <code class="p">}</code>
  <code class="p">]</code><code class="err">,</code></pre>

<p>Once we do this, we can now finally add the executable scripts to our <em>package.json</em>. Add the <a data-type="indexterm" data-primary="scripts section in package.json" id="idm139828106918032"></a>following commands to the <code>scripts</code> section in your <em>package.json</em>:</p>

<pre data-type="programlisting" data-code-language="json"><code class="s2">"build:universal"</code><code class="err">:</code>
    <code class="s2">"npm run build:client-and-server-bundles &amp;&amp; npm run webpack:server"</code><code class="err">,</code>
<code class="s2">"serve:universal"</code><code class="err">:</code> <code class="s2">"node dist/server.js"</code><code class="err">,</code>
<code class="s2">"webpack:server"</code><code class="err">:</code> <code class="s2">"webpack --config webpack.server.config.js --progress --colors"</code></pre>

<p>At this point, we should now be ready to run our Angular Universal application.</p>
</div></section>













<section data-type="sect3" data-pdf-bookmark="Running Angular Universal"><div class="sect3" id="idm139828107032400">
<h3>Running Angular Universal</h3>

<p>Building our Angular Universal application is<a data-type="indexterm" data-primary="Angular Universal" data-secondary="running" id="idm139828107030368"></a><a data-type="indexterm" data-primary="server-side rendering and handling SEO" data-secondary="running Angular Universal" id="idm139828107029392"></a><a data-type="indexterm" data-primary="productionizing Angular apps" data-secondary="server-side rendering and handling SEO" data-tertiary="running Angular Universal" id="idm139828107028512"></a> now as simple as executing:</p>
<pre data-type="programlisting">
<strong>npm run build:universal</strong>
</pre>

<p>This runs and generates the build for both our server- and browser-side Angular applications. It creates two folders in our <em>dist</em> folder, one each for <em>browser</em> and for <em>server</em>.</p>

<p>Now we can run our Angular application as:</p>
<pre data-type="programlisting">
<strong>npm run serve:universal</strong>
</pre>

<p>This should now start your application, and allow you to hit the application at <em>http://localhost:4000</em>.</p>

<p>When you open the URL in your browser, open the Network Inspector and look at the requests being made and the responses. In particular, notice the very first request. With a normal Angular application, you would see the barebones <em>index.html</em> being served, which would then load all the relevant source code and trigger Angular.</p>

<p>In this case though, you would see that the very first request itself comes with the route content preloaded, and the template HTML also loaded. It is then that the rest of Angular triggers and starts working in the background. This becomes even more apparent if you throttle the speed to 3G or below, to see the difference in perceived latency in an Angular Universal application versus a normal Angular application.</p>

<p>The finished code for this application is available in the <em>chapter12/server-side-rendering</em> folder in the GitHub repository.<a data-type="indexterm" data-primary="search engine optimization (SEO)" data-startref="ix_SEO" id="idm139828106809680"></a><a data-type="indexterm" data-primary="productionizing Angular apps" data-secondary="server-side rendering and handling SEO" data-startref="ix_prodser" id="idm139828106808672"></a><a data-type="indexterm" data-primary="server-side rendering and handling SEO" data-startref="ix_serside" id="idm139828106807424"></a></p>
</div></section>



</div></section>





</div></section>













<section data-type="sect1" data-pdf-bookmark="Conclusion"><div class="sect1" id="idm139828108488448">
<h1>Conclusion</h1>

<p>This brings us to the end of our journey of learning Angular, step by step.<a data-type="indexterm" data-primary="productionizing Angular apps" data-startref="ix_prod" id="idm139828106805280"></a> In this chapter in particular, we covered what it takes to bring the Angular application you have been building so far to production. We covered all the steps from building to deploying, and then went in-depth into various concerns for performance, from caching to prerendering. We also touched upon lazy loading and saw how simple it is to take an Angular application and move it to lazy load certain sections of your <span class="keep-together">application</span>.</p>

<p>That said, we have just begun to scratch the surface of Angular. There are tons of things in Angular itself that we didn’t cover in this book, from creating directives and pipes, to advanced concepts. But what we have done is build a solid base for you to build from, and covered about 80%–90% of the common tasks you will have in building any application. From here, you should be able to build pretty complex things, and leverage the official documentation to see you the rest of the way through.</p>
</div></section>







</div></section></div>
</body>
</html>