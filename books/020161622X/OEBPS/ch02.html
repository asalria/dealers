<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" xmlns:m="http://www.w3.org/1998/Math/MathML" xmlns:pls="http://www.w3.org/2005/01/pronunciation-lexicon" xmlns:ssml="http://www.w3.org/2001/10/synthesis" xmlns:svg="http://www.w3.org/2000/svg">
<head>
  <meta charset="UTF-8" />
  <title>Chapter 2. A Pragmatic Approach</title>
  <link type="text/css" rel="stylesheet" media="all" href="style.css" />
  <link type="text/css" rel="stylesheet" media="all" href="core.css" />
</head>
<body>
  <div id="sbo-rt-content"><p><a id="ch02"></a><a id="page_25"></a></p>
<h2 id="title-IDATXM0" class="docChapterTitle">Chapter 2<br/><br/>A Pragmatic Approach</h2>
<p class="docText">There are certain tips and tricks that apply at all levels of software development, ideas that are almost axiomatic, and processes that are virtually universal. However, these approaches are rarely documented as such; you'll mostly find them written down as odd sentences in discussions of design, project management, or coding.</p>
<p class="docText">In this chapter we'll bring these ideas and processes together. The first two sections, <em>The Evils of Duplication</em> and <em>Orthogonality,</em> are closely related. The first warns you not to duplicate knowledge throughout your systems, the second not to split any one piece of knowledge across multiple system components.</p>
<p class="docText">As the pace of change increases, it becomes harder and harder to keep our applications relevant. In <em>Reversibility,</em> we'll look at some techniques that help insulate your projects from their changing environment.</p>
<p class="docText">The next two sections are also related. In <em>Tracer Bullets,</em> we talk about a style of development that allows you to gather requirements, test designs, and implement code at the same time. If this sounds too good to be true, it is: tracer bullet developments are not always applicable. When they're not, <em>Prototypes and Post-it Notes</em> shows you how to use prototyping to test architectures, algorithms, interfaces, and ideas.</p>
<p class="docText">As computer science slowly matures, designers are producing increasingly higher-level languages. While the compiler that accepts "make it so" hasn't yet been invented, in <em>Domain Languages</em> we present some more modest suggestions that you can implement for yourself.</p>
<p class="docText"><a id="page_26"></a>Finally, we all work in a world of limited time and resources. You can survive both of these scarcities better (and keep your bosses happier) if you get good at working out how long things will take, which we cover in <em>Estimating.</em></p>
<p class="docText">By keeping these fundamental principles in mind during development, you can write code that's better, faster, and stronger. You can even make it look easy.</p>
<p class="docText"><a id="ch02lev1sec1"></a></p>
<h3 id="title-IDA4YM0" class="docSection1Title">7. The Evils of Duplication</h3>
<p class="docText">Giving a computer two contradictory pieces of knowledge was Captain James T. Kirk's preferred way of disabling a marauding artificial intelligence. Unfortunately, the same principle can be effective in bringing down <em>your</em> code.</p>
<p class="docText">As programmers, we collect, organize, maintain, and harness knowledge. We document knowledge in specifications, we make it come alive in running code, and we use it to provide the checks needed during testing.</p>
<p class="docText">Unfortunately, knowledge isn't stable. It changes—often rapidly. Your understanding of a requirement may change following a meeting with the client. The government changes a regulation and some business logic gets outdated. Tests may show that the chosen algorithm won't work. All this instability means that we spend a large part of our time in maintenance mode, reorganizing and reexpressing the knowledge in our systems.</p>
<p class="docText">Most people assume that maintenance begins when an application is released, that maintenance means fixing bugs and enhancing features. We think these people are wrong. Programmers are constantly in maintenance mode. Our understanding changes day by day. New requirements arrive as we're designing or coding. Perhaps the environment changes. Whatever the reason, maintenance is not a discrete activity, but a routine part of the entire development process.</p>
<p class="docText"><a id="page_27"></a>When we perform maintenance, we have to find and change the representations of things—those capsules of knowledge embedded in the application. The problem is that it's easy to duplicate knowledge in the specifications, processes, and programs that we develop, and when we do so, we invite a maintenance nightmare—one that starts well before the application ships.</p>
<p class="docText">We feel that the only way to develop software reliably, and to make our developments easier to understand and maintain, is to follow what we call the <em>DRY</em> principle:</p>
<p class="blockquote">E<small>VERY PIECE OF KNOWLEDGE MUST HAVE A SINGLE, UNAMBIGUOUS, AUTHORITATIVE REPRESENTATION WITHIN A SYSTEM</small>.</p>
<p class="docText">Why do we call it <em>DRY?</em></p>
<p class="docNoteTitle">Tip 11</p>
<p class="note"><a href="app03.html#id1e2185"><em>DRY</em>—<em>D</em>on't <em>R</em>epeat <em>Y</em>ourself</a></p>
<p class="docText">The alternative is to have the same thing expressed in two or more places. If you change one, you have to remember to change the others, or, like the alien computers, your program will be brought to its knees by a contradiction. It isn't a question of whether you'll remember: it's a question of when you'll forget.</p>
<p class="docText">You'll find the <em>DRY</em> principle popping up time and time again throughout this book, often in contexts that have nothing to do with coding. We feel that it is one of the most important tools in the Pragmatic Programmer's tool box.</p>
<p class="docText">In this section we'll outline the problems of duplication and suggest general strategies for dealing with it.</p>
<p class="docText"><a id="ch02lev2sec1"></a></p>
<h4 id="title-IDAK1M0" class="docSection2Title">How Does Duplication Arise?</h4>
<p class="docText">Most of the duplication we see falls into one of the following categories:</p>
<ul>
<li><a id="d1e2226"></a><strong>Imposed duplication.</strong> Developers feel they have no choice—the environment seems to require duplication.</li>
<li><a id="d1e2234"></a><strong>Inadvertent duplication.</strong> Developers don't realize that they are duplicating information.</li>
<li><a id="page_28"></a><a id="d1e2242"></a><strong>Impatient duplication.</strong> Developers get lazy and duplicate because it seems easier.</li>
<li><a id="d1e2250"></a><strong>Interdeveloper duplication.</strong> Multiple people on a team (or on different teams) duplicate a piece of information.</li>
</ul>
<p class="docText">Let's look at these four <em>i</em>'s of duplication in more detail.</p>
<p class="docText"><a id="ch02lev2sec2"></a></p>
<h4 id="title-IDAM3M0" class="docSection2Title">Imposed Duplication</h4>
<p class="docText">Sometimes, duplication seems to be forced on us. Project standards may require documents that contain duplicated information, or documents that duplicate information in the code. Multiple target platforms each require their own programming languages, libraries, and development environments, which makes us duplicate shared definitions and procedures. Programming languages themselves require certain structures that duplicate information. We have all worked in situations where we felt powerless to avoid duplication. And yet often there are ways of keeping each piece of knowledge in one place, honoring the <em>DRY</em> principle, and making our lives easier at the same time. Here are some techniques:</p>
<p class="docText"><a id="d1e2276"></a><strong><em>Multiple representations of information.</em></strong> At the coding level, we often need to have the same information represented in different forms. Maybe we're writing a client-server application, using different languages on the client and server, and need to represent some shared structure on both. Perhaps we need a class whose attributes mirror the schema of a database table. Maybe you're writing a book and want to include excerpts of programs that you also will compile and test.</p>
<p class="docText">With a bit of ingenuity you can normally remove the need for duplication. Often the answer is to write a simple filter or code generator. Structures in multiple languages can be built from a common metadata representation using a simple code generator each time the software is built (an example of this is shown in <a href="ch03.html#ch03fig04">Figure 3.4</a>, page <a href="ch03.html#page_106">106</a>). Class definitions can be generated automatically from the online database schema, or from the metadata used to build the schema in the first place. The code extracts in this book are inserted by a preprocessor each time we format the text. The trick is to make the process active: this cannot be a one-time conversion, or we're back in a position of duplicating data.</p>
<p class="docText"><a id="page_29"></a><a id="d1e2289"></a><strong><em>Documentation in code.</em></strong> Programmers are taught to comment their code: good code has lots of comments. Unfortunately, they are never taught <em>why</em> code needs comments: bad code <em>requires</em> lots of comments.</p>
<p class="docText">The <em>DRY</em> principle tells us to keep the low-level knowledge in the code, where it belongs, and reserve the comments for other, high-level explanations. Otherwise, we're duplicating knowledge, and every change means changing both the code and the comments. The comments will inevitably become out of date, and untrustworthy comments are worse than no comments at all. (See <a href="ch08.html#ch08lev1sec4"><em>It's All Writing</em></a>, page <a href="ch08.html#page_248">248</a>, for more information on comments.)</p>
<p class="docText"><a id="d1e2311"></a><strong><em>Documentation and code.</em></strong> You write documentation, then you write code. Something changes, and you amend the documentation and update the code. The documentation and code both contain representations of the same knowledge. And we all know that in the heat of the moment, with deadlines looming and important clients clamoring, we tend to defer the updating of documentation.</p>
<p class="docText">Dave once worked on an international telex switch. Quite understandably, the client demanded an exhaustive test specification and required that the software pass all tests on each delivery. To ensure that the tests accurately reflected the specification, the team generated them programmatically from the document itself. When the client amended their specification, the test suite changed automatically. Once the team convinced the client that the procedure was sound, generating acceptance tests typically took only a few seconds.</p>
<p class="docText"><a id="d1e2321"></a><strong><em>Language issues.</em></strong> Many languages impose considerable duplication in the source. Often this comes about when the language separates a module's interface from its implementation. C and C++ have header files that duplicate the names and type information of exported variables, functions, and (for C++) classes. Object Pascal even duplicates this information in the same file. If you are using remote procedure calls or CORBA [<a href="app01.html#app01lev3sec29">URL 29</a>], you'll duplicate interface information between the interface specification and the code that implements it.</p>
<p class="docText">There is no easy technique for overcoming the requirements of a language. While some development environments hide the need for header files by generating them automatically, and Object Pascal allows you to abbreviate repeated function declarations, you are generally stuck <a id="page_30"></a>with what you're given. At least with most language-based issues, a header file that disagrees with the implementation will generate some form of compilation or linkage error. You can still get things wrong, but at least you'll be told about it fairly early on.</p>
<p class="docText">Think also about comments in header and implementation files. There is absolutely no point in duplicating a function or class header comment between the two files. Use the header files to document interface issues, and the implementation files to document the nitty-gritty details that users of your code don't need to know.</p>
<p class="docText"><a id="ch02lev2sec3"></a></p>
<h4 id="title-IDA45M0" class="docSection2Title">Inadvertent Duplication</h4>
<p class="docText">Sometimes, duplication comes about as the result of mistakes in the design.</p>
<p class="docText">Let's look at an example from the distribution industry. Say our analysis reveals that, among other attributes, a truck has a type, a license number, and a driver. Similarly, a delivery route is a combination of a route, a truck, and a driver. We code up some classes based on this understanding.</p>
<p class="docText">But what happens when Sally calls in sick and we have to change drivers? Both <code>Truck</code> and <code>DeliveryRoute</code> contain a driver. Which one do we change? Clearly this duplication is bad. Normalize it according to the underlying business model—does a truck really have a driver as part of its underlying attribute set? Does a route? Or maybe there needs to be a third object that knits together a driver, a truck, and a route. Whatever the eventual solution, avoid this kind of unnormalized data.</p>
<p class="docText">There is a slightly less obvious kind of unnormalized data that occurs when we have multiple data elements that are mutually dependent. Let's look at a class representing a line:</p>
<p class="progimage"><img src="images/p0030-01.jpg" alt="image" /></p>
<p class="docText">At first sight, this class might appear reasonable. A line clearly has a start and end, and will always have a length (even if it's zero). But we <a id="page_31"></a>have duplication. The length is defined by the start and end points: change one of the points and the length changes. It's better to make the length a calculated field:</p>
<p class="progimage"><img src="images/p0031-01.jpg" alt="image" /></p>
<p class="docText">Later on in the development process, you may choose to violate the <em>DRY</em> principle for performance reasons. Frequently this occurs when you need to cache data to avoid repeating expensive operations. The trick is to localize the impact. The violation is not exposed to the outside world: only the methods within the class have to worry about keeping things straight.</p>
<p class="image1"><img src="images/p0031-02.jpg" alt="image" /></p>
<p class="docText">This example also illustrates an important issue for object-oriented languages such as Java and C++. Where possible, always use accessor functions to read and write the attributes of objects.<sup><a href="#ch02fn01">[1]</a></sup> It will make it easier to add functionality, such as caching, in the future.</p>
<p class="docFootnote"><sup><a id="ch02fn01">[1]</a></sup> The use of accessor functions ties in with Meyer's <em>Uniform Access principle</em> [Mey97b], which states that "All services offered by a module should be available through a uniform notation, which does not betray whether they are implemented through storage or through computation."</p>
<p class="docText"><a id="ch02lev2sec4"></a><a id="page_32"></a></p>
<h4 id="title-IDAWEN0" class="docSection2Title">Impatient Duplication</h4>
<p class="docText">Every project has time pressures—forces that can drive the best of us to take shortcuts. Need a routine similar to one you've written? You'll be tempted to copy the original and make a few changes. Need a value to represent the maximum number of points? If I change the header file, the whole project will get rebuilt. Maybe I should just use a literal number here; and here; and here. Need a class like one in the Java runtime? The source is available, so why not just copy it and make the changes you need (license provisions notwithstanding)?</p>
<p class="docText">If you feel this temptation, remember the hackneyed aphorism "shortcuts make for long delays." You may well save some seconds now, but at the potential loss of hours later. Think about the issues surrounding the Y2K fiasco. Many were caused by the laziness of developers not parameterizing the size of date fields or implementing centralized libraries of date services.</p>
<p class="docText">Impatient duplication is an easy form to detect and handle, but it takes discipline and a willingness to spend time up front to save pain later.</p>
<p class="docText"><a id="ch02lev2sec5"></a></p>
<h4 id="title-IDAJFN0" class="docSection2Title">Interdeveloper Duplication</h4>
<p class="docText">On the other hand, perhaps the hardest type of duplication to detect and handle occurs between different developers on a project. Entire sets of functionality may be inadvertently duplicated, and that duplication could go undetected for years, leading to maintenance problems. We heard firsthand of a U.S. state whose governmental computer systems were surveyed for Y2K compliance. The audit turned up more than 10,000 programs, each containing its own version of Social Security number validation.</p>
<p class="docText">At a high level, deal with the problem by having a clear design, a strong technical project leader (see page <a href="ch08.html#page_228">228</a> in <a href="ch08.html#ch08lev1sec1"><em>Pragmatic Teams</em></a>), and a well-understood division of responsibilities within the design. However, at the module level, the problem is more insidious. Commonly needed functionality or data that doesn't fall into an obvious area of responsibility can get implemented many times over.</p>
<p class="docText">We feel that the best way to deal with this is to encourage active and frequent communication between developers. Set up forums to discuss common problems. (On past projects, we have set up private Usenet <a id="page_33"></a>newsgroups to allow developers to exchange ideas and ask questions. This provides a nonintrusive way of communicating—even across multiple sites—while retaining a permanent history of everything said.) Appoint a team member as the project librarian, whose job is to facilitate the exchange of knowledge. Have a central place in the source tree where utility routines and scripts can be deposited. And make a point of reading other people's source code and documentation, either informally or during code reviews. You're not snooping—you're learning from them. And remember, the access is reciprocal—don't get twisted about other people poring (pawing?) through <em>your</em> code, either.</p>
<p class="docNoteTitle">Tip 12</p>
<p class="note"><a href="app03.html#id1e2492">Make It Easy to Reuse</a></p>
<p class="docText">What you're trying to do is foster an environment where it's easier to find and reuse existing stuff than to write it yourself. <em>If it isn't easy, people won't do it.</em> And if you fail to reuse, you risk duplicating knowledge.</p>
<p class="docText"><a id="ch02lev3sec1"></a></p>
<h5 id="title-IDAXGN0" class="docSection3Title">Related sections include:</h5>
<ul>
<li><a href="ch02.html#ch02lev1sec2"><em>Orthogonality</em></a>, page <a href="ch02.html#page_34">34</a></li>
<li><a href="ch03.html#ch03lev1sec6"><em>Text Manipulation</em></a>, page <a href="ch03.html#page_99">99</a></li>
<li><a href="ch03.html#ch03lev1sec7"><em>Code Generators</em></a>, page <a href="ch03.html#page_102">102</a></li>
<li><a href="ch06.html#ch06lev1sec3"><em>Refactoring</em></a>, page <a href="ch06.html#page_184">184</a></li>
<li><a href="ch08.html#ch08lev1sec1"><em>Pragmatic Teams</em></a>, page <a href="ch08.html#page_224">224</a></li>
<li><a href="ch08.html#ch08lev1sec2"><em>Ubiquitous Automation</em></a>, page <a href="ch08.html#page_230">230</a></li>
<li><a href="ch08.html#ch08lev1sec4"><em>It's All Writing</em></a>, page <a href="ch08.html#page_248">248</a></li>
</ul>
<p class="docText"><a id="ch02lev1sec2"></a><a id="page_34"></a></p>
<h3 id="title-IDAVIN0" class="docSection1Title">8. Orthogonality</h3>
<p class="docText">Orthogonality is a critical concept if you want to produce systems that are easy to design, build, test, and extend. However, the concept of orthogonality is rarely taught directly. Often it is an implicit feature of various other methods and techniques you learn. This is a mistake. Once you learn to apply the principle of orthogonality directly, you'll notice an immediate improvement in the quality of systems you produce.</p>
<p class="docText"><a id="ch02lev2sec6"></a></p>
<h4 id="title-IDA5IN0" class="docSection2Title">What Is Orthogonality?</h4>
<p class="docText">"Orthogonality" is a term borrowed from geometry. Two lines are orthogonal if they meet at right angles, such as the axes on a graph. In vector terms, the two lines are <em>independent.</em> Move along one of the lines, and your position projected onto the other doesn't change.</p>
<p class="image1"><img src="images/orthogonality.gif" alt="image" /></p>
<p class="docText">In computing, the term has come to signify a kind of independence or decoupling. Two or more things are orthogonal if changes in one do not affect any of the others. In a well-designed system, the database code will be orthogonal to the user interface: you can change the interface without affecting the database, and swap databases without changing the interface.</p>
<p class="docText">Before we look at the benefits of orthogonal systems, let's first look at a system that isn't orthogonal.</p>
<p class="docText"><a id="ch02lev3sec2"></a></p>
<h5 id="title-IDA0JN0" class="docSection3Title">A Nonorthogonal System</h5>
<p class="docText">You're on a helicopter tour of the Grand Canyon when the pilot, who made the obvious mistake of eating fish for lunch, suddenly groans and faints. Fortunately, he left you hovering 100 feet above the ground. You rationalize that the collective pitch lever<sup><a href="#ch02fn02">[2]</a></sup> controls overall lift, so lowering <a id="page_35"></a>it slightly will start a gentle descent to the ground. However, when you try it, you discover that life isn't that simple. The helicopter's nose drops, and you start to spiral down to the left. Suddenly you discover that you're flying a system where every control input has secondary effects. Lower the left-hand lever and you need to add compensating backward movement to the right-hand stick and push the right pedal. But then each of these changes affects all of the other controls again. Suddenly you're juggling an unbelievably complex system, where every change impacts all the other inputs. Your workload is phenomenal: your hands and feet are constantly moving, trying to balance all the interacting forces.</p>
<p class="docFootnote"><sup><a id="ch02fn02">[2]</a></sup> Helicopters have four basic controls. The <em>cyclic</em> is the stick you hold in your right hand. Move it, and the helicopter moves in the corresponding direction. Your left hand holds the <em>collective pitch lever.</em> Pull up on this and you increase the pitch on all the blades, generating lift. At the end of the pitch lever is the <em>throttle.</em> Finally you have two foot <em>pedals,</em> which vary the amount of tail rotor thrust and so help turn the helicopter.</p>
<p class="docText">Helicopter controls are decidedly not orthogonal.</p>
<p class="docText"><a id="ch02lev2sec7"></a></p>
<h4 id="title-IDAYKN0" class="docSection2Title">Benefits of Orthogonality</h4>
<p class="docText">As the helicopter example illustrates, nonorthogonal systems are inherently more complex to change and control. When components of any system are highly interdependent, there is no such thing as a local fix.</p>
<p class="docNoteTitle">Tip 13</p>
<p class="note"><a href="app03.html#id1e2619">Eliminate Effects Between Unrelated Things</a></p>
<p class="docText">We want to design components that are self-contained: independent, and with a single, well-defined purpose (what Yourdon and Constantine call <em>cohesion</em> [<a href="app01.html#yc86">YC86</a>]). When components are isolated from one another, you know that you can change one without having to worry about the rest. As long as you don't change that component's external interfaces, you can be comfortable that you won't cause problems that ripple through the entire system.</p>
<p class="docText">You get two major benefits if you write orthogonal systems: increased productivity and reduced risk.</p>
<p class="docText"><a id="ch02lev3sec3"></a></p>
<h5 id="title-IDAULN0" class="docSection3Title">Gain Productivity</h5>
<ul>
<li>Changes are localized, so development time and testing time are reduced. It is easier to write relatively small, self-contained components than a single large block of code. Simple components can be <a id="page_36"></a>designed, coded, unit tested, and then forgotten—there is no need to keep changing existing code as you add new code.</li>
<li>An orthogonal approach also promotes reuse. If components have specific, well-defined responsibilities, they can be combined with new components in ways that were not envisioned by their original implementors. The more loosely coupled your systems, the easier they are to reconfigure and reengineer.</li>
<li>There is a fairly subtle gain in productivity when you combine orthogonal components. Assume that one component does <em>M</em> distinct things and another does <em>N</em> things. If they are orthogonal and you combine them, the result does <em>M x N</em> things. However, if the two components are not orthogonal, there will be overlap, and the result will do less. You get more functionality per unit effort by combining orthogonal components.</li>
</ul>
<p class="docText"><a id="ch02lev3sec4"></a></p>
<h5 id="title-IDAXMN0" class="docSection3Title">Reduce Risk</h5>
<p class="docText">An orthogonal approach reduces the risks inherent in any development.</p>
<ul>
<li>Diseased sections of code are isolated. If a module is sick, it is less likely to spread the symptoms around the rest of the system. It is also easier to slice it out and transplant in something new and healthy.</li>
<li>The resulting system is less fragile. Make small changes and fixes to a particular area, and any problems you generate will be restricted to that area.</li>
<li>An orthogonal system will probably be better tested, because it will be easier to design and run tests on its components.</li>
<li>You will not be as tightly tied to a particular vendor, product, or platform, because the interfaces to these third-party components will be isolated to smaller parts of the overall development.</li>
</ul>
<p class="docText">Let's look at some of the ways you can apply the principle of orthogonality to your work.</p>
<p class="docText"><a id="ch02lev2sec8"></a></p>
<h4 id="title-IDAXNN0" class="docSection2Title">Project Teams</h4>
<p class="docText">Have you noticed how some project teams are efficient, with everyone knowing what to do and contributing fully, while the members of other <a id="page_37"></a>teams are constantly bickering and don't seem able to get out of each other's way?</p>
<p class="docText">Often this is an orthogonality issue. When teams are organized with lots of overlap, members are confused about responsibilities. Every change needs a meeting of the entire team, because any one of them <em>might</em> be affected.</p>
<p class="docText">How do you organize teams into groups with well-defined responsibilities and minimal overlap? There's no simple answer. It depends partly on the project and your analysis of the areas of potential change. It also depends on the people you have available. Our preference is to start by separating infrastructure from application. Each major infrastructure component (database, communications interface, middleware layer, and so on) gets its own subteam. Each obvious division of application functionality is similarly divided. Then we look at the people we have (or plan to have) and adjust the groupings accordingly.</p>
<p class="docText">You can get an informal measure of the orthogonality of a project team's structure. Simply see how many people <em>need</em> to be involved in discussing each change that is requested. The larger the number, the less orthogonal the group. Clearly, an orthogonal team is more efficient. (Having said this, we also encourage subteams to communicate constantly with each other.)</p>
<p class="docText"><a id="ch02lev2sec9"></a></p>
<h4 id="title-IDAOON0" class="docSection2Title">Design</h4>
<p class="docText">Most developers are familiar with the need to design orthogonal systems, although they may use words such as <em>modular, component-based,</em> and <em>layered</em> to describe the process. Systems should be composed of a set of cooperating modules, each of which implements functionality independent of the others. Sometimes these components are organized into layers, each providing a level of abstraction. This layered approach is a powerful way to design orthogonal systems. Because each layer uses only the abstractions provided by the layers below it, you have great flexibility in changing underlying implementations without affecting code. Layering also reduces the risk of runaway dependencies between modules. You'll often see layering expressed in diagrams such as <a href="#ch02fig01">Figure 2.1</a> on the next page.</p>
<p class="docText"><a id="ch02fig01"></a></p>
<p class="docFigureTitle">Figure 2.1. Typical layer diagram</p>
<p class="image"><img src="images/f02fig01.gif" alt="image" /></p>
<p class="docText">There is an easy test for orthogonal design. Once you have your components mapped out, ask yourself: <em>If I dramatically change the requirements <a id="page_38"></a>behind a particular function, how many modules are affected?</em> In an orthogonal system, the answer should be "one."<sup><a href="#ch02fn03">[3]</a></sup> Moving a button on a GUI panel should not require a change in the database schema. Adding context-sensitive help should not change the billing subsystem.</p>
<p class="docFootnote"><sup><a id="ch02fn03">[3]</a></sup> In reality, this is naive. Unless you are remarkably lucky, most real-world requirements changes will affect multiple functions in the system. However, if you analyze the change in terms of functions, each functional change should still ideally affect just one module.</p>
<p class="docText">Let's consider a complex system for monitoring and controlling a heating plant. The original requirement called for a graphical user interface, but the requirements were changed to add a voice response system with touchtone telephone control of the plant. In an orthogonally designed system, you would need to change only those modules associated with the user interface to handle this: the underlying logic of controlling the plant would remain unchanged. In fact, if you structure your system carefully, you should be able to support both interfaces with the same underlying code base. <a href="ch05.html#ch05lev1sec4"><em>It's Just a View</em></a>, page <a href="ch05.html#page_157">157</a>, talks about writing decoupled code using the Model-View-Controller (MVC) paradigm, which works well in this situation.</p>
<p class="docText"><a id="page_39"></a>Also ask yourself how decoupled your design is from changes in the real world. Are you using a telephone number as a customer identifier? What happens when the phone company reassigns area codes? <em>Don't rely on the properties of things you can't control.</em></p>
<p class="docText"><a id="ch02lev2sec10"></a></p>
<h4 id="title-IDANQN0" class="docSection2Title">Toolkits and Libraries</h4>
<p class="docText">Be careful to preserve the orthogonality of your system as you introduce third-party toolkits and libraries. Choose your technologies wisely.</p>
<p class="docText">We once worked on a project that required that a certain body of Java code run both locally on a server machine and remotely on a client machine. The alternatives for distributing classes this way were RMI and CORBA. If a class were made remotely accessible using RMI, every call to a remote method in that class could potentially throw an exception, which means that a naive implementation would require us to handle the exception whenever our remote classes were used. Using RMI here is clearly not orthogonal: code calling our remote classes should not have to be aware of their locations. The alternative—using CORBA—did not impose that restriction: we could write code that was unaware of our classes' locations.</p>
<p class="docText">When you bring in a toolkit (or even a library from other members of your team), ask yourself whether it imposes changes on your code that shouldn't be there. If an object persistence scheme is transparent, then it's orthogonal. If it requires you to create or access objects in a special way, then it's not. Keeping such details isolated from your code has the added benefit of making it easier to change vendors in the future.</p>
<p class="docText">The Enterprise Java Beans (EJB) system is an interesting example of orthogonality. In most transaction-oriented systems, the application code has to delineate the start and end of each transaction. With EJB, this information is expressed declaratively as metadata, outside any code. The same application code can run in different EJB transaction environments with no change. This is likely to be a model for many future environments.</p>
<p class="docText">Another interesting twist on orthogonality is Aspect-Oriented Programming (AOP), a research project at Xerox Parc ([<a href="app01.html#klm97">KLM<sup>+</sup>97</a>] and [<a href="app01.html#app01lev3sec49">URL 49</a>]). AOP lets you express in one place behavior that would otherwise be distributed throughout your source code. For example, log messages <a id="page_40"></a>are normally generated by sprinkling explicit calls to some log function throughout your source. With AOP, you implement logging orthogonally to the things being logged. Using the Java version of AOP, you could write a log message when entering any method of class <code>Fred</code> by coding the <em>aspect</em>:</p>
<p class="progimage"><img src="images/p0040-01.jpg" alt="image" /></p>
<p class="docText">If you <em>weave</em> this aspect into your code, trace messages will be generated. If you don't, you'll see no messages. Either way, your original source is unchanged.</p>
<p class="docText"><a id="ch02lev2sec11"></a></p>
<h4 id="title-IDAPSN0" class="docSection2Title">Coding</h4>
<p class="docText">Every time you write code you run the risk of reducing the orthogonality of your application. Unless you constantly monitor not just what you are doing but also the larger context of the application, you might unintentionally duplicate functionality in some other module, or express existing knowledge twice.</p>
<p class="docText">There are several techniques you can use to maintain orthogonality:</p>
<ul>
<li><a id="d1e2841"></a><strong>Keep your code decoupled.</strong> Write shy code—modules that don't reveal anything unnecessary to other modules and that don't rely on other modules' implementations. Try the Law of Demeter [<a href="app01.html#lh89">LH89</a>], which we discuss in <a href="ch05.html#ch05lev1sec1"><em>Decoupling and the Law of Demeter</em></a>, page <a href="ch05.html#page_138">138</a>. If you need to change an object's state, get the object to do it for you. This way your code remains isolated from the other code's implementation and increases the chances that you'll remain orthogonal.</li>
<li><a id="d1e2855"></a><strong>Avoid global data.</strong> Every time your code references global data, it ties itself into the other components that share that data. Even globals that you intend only to read can lead to trouble (for example, if you suddenly need to change your code to be multithreaded). In general, your code is easier to understand and maintain if you explicitly pass any required context into your modules. In object-oriented applications, context is often passed as parameters to <a id="page_41"></a>objects' constructors. In other code, you can create structures containing the context and pass around references to them.<br/>The Singleton pattern in <em>Design Patterns</em> [<a href="app01.html#ghjv95">GHJV95</a>] is a way of ensuring that there is only one instance of an object of a particular class. Many people use these singleton objects as a kind of global variable (particularly in languages, such as Java, that otherwise do not support the concept of globals). Be careful with singletons—they can also lead to unnecessary linkage.</li>
<li><a id="d1e2871"></a><strong>Avoid similar functions.</strong> Often you'll come across a set of functions that all look similar—maybe they share common code at the start and end, but each has a different central algorithm. Duplicate code is a symptom of structural problems. Have a look at the Strategy pattern in <em>Design Patterns</em> for a better implementation.</li>
</ul>
<p class="docText">Get into the habit of being constantly critical of your code. Look for any opportunities to reorganize it to improve its structure and orthogonality. This process is called <em>refactoring,</em> and it's so important that we've dedicated a section to it (see <a href="ch06.html#ch06lev1sec3"><em>Refactoring</em></a>, page <a href="ch06.html#page_184">184</a>).</p>
<p class="docText"><a id="ch02lev2sec12"></a></p>
<h4 id="title-IDAGVN0" class="docSection2Title">Testing</h4>
<p class="docText">An orthogonally designed and implemented system is easier to test. Because the interactions between the system's components are formalized and limited, more of the system testing can be performed at the individual module level. This is good news, because module level (or unit) testing is considerably easier to specify and perform than integration testing. In fact, we suggest that every module have its own unit test built into its code, and that these tests be performed automatically as part of the regular build process (see <a href="ch06.html#ch06lev1sec4"><em>Code That's Easy to Test</em></a>, page <a href="ch06.html#page_189">189</a>).</p>
<p class="docText">Building unit tests is itself an interesting test of orthogonality. What does it take to build and link a unit test? Do you have to drag in a large percentage of the rest of the system just to get a test to compile or link? If so, you've found a module that is not well decoupled from the rest of the system.</p>
<p class="docText">Bug fixing is also a good time to assess the orthogonality of the system as a whole. When you come across a problem, assess how localized <a id="page_42"></a>the fix is. Do you change just one module, or are the changes scattered throughout the entire system? When you make a change, does it fix everything, or do other problems mysteriously arise? This is a good opportunity to bring automation to bear. If you use a source code control system (and you will after reading <a href="ch03.html#ch03lev1sec4"><em>Source Code Control</em></a>, page <a href="ch03.html#page_86">86</a>), tag bug fixes when you check the code back in after testing. You can then run monthly reports analyzing trends in the number of source files affected by each bug fix.</p>
<p class="docText"><a id="ch02lev2sec13"></a></p>
<h4 id="title-IDA5VN0" class="docSection2Title">Documentation</h4>
<p class="docText">Perhaps surprisingly, orthogonality also applies to documentation. The axes are content and presentation. With truly orthogonal documentation, you should be able to change the appearance dramatically without changing the content. Modern word processors provide style sheets and macros that help (see <a href="ch08.html#ch08lev1sec4"><em>It's All Writing</em></a>, page <a href="ch08.html#page_248">248</a>).</p>
<p class="docText"><a id="ch02lev2sec14"></a></p>
<h4 id="title-IDAPWN0" class="docSection2Title">Living with Orthogonality</h4>
<p class="docText">Orthogonality is closely related to the <em>DRY</em> principle introduced on page <a href="ch02.html#page_27">27</a>. With <em>DRY,</em> you're looking to minimize duplication within a system, whereas with orthogonality you reduce the interdependency among the system's components. It may be a clumsy word, but if you use the principle of orthogonality, combined closely with the <em>DRY</em> principle, you'll find that the systems you develop are more flexible, more understandable, and easier to debug, test, and maintain.</p>
<p class="docText">If you're brought into a project where people are desperately struggling to make changes, and where every change seems to cause four other things to go wrong, remember the nightmare with the helicopter. The project probably is not orthogonally designed and coded. It's time to refactor.</p>
<p class="docText">And, if you're a helicopter pilot, don't eat the fish....</p>
<p class="docText"><a id="ch02lev3sec5"></a></p>
<h5 id="title-IDAIXN0" class="docSection3Title">Related sections include:</h5>
<ul>
<li><a href="ch02.html#ch02lev1sec1"><em>The Evils of Duplication</em></a>, page <a href="ch02.html#page_26">26</a></li>
<li><a href="ch03.html#ch03lev1sec4"><em>Source Code Control</em></a>, page <a href="ch03.html#page_86">86</a></li>
<li><a href="ch04.html#ch04lev1sec1"><em>Design by Contract</em></a>, page <a href="ch04.html#page_109">109</a></li>
<li><a href="ch05.html#ch05lev1sec1"><em>Decoupling and the Law of Demeter</em></a>, page <a href="ch05.html#page_138">138</a></li>
<li><a id="page_43"></a><a href="ch05.html#ch05lev1sec2"><em>Metaprogramming</em></a>, page <a href="ch05.html#page_144">144</a></li>
<li><a href="ch05.html#ch05lev1sec4"><em>It's Just a View</em></a>, page <a href="ch05.html#page_157">157</a></li>
<li><a href="ch06.html#ch06lev1sec3"><em>Refactoring</em></a>, page <a href="ch06.html#page_184">184</a></li>
<li><a href="ch06.html#ch06lev1sec4"><em>Code That's Easy to Test</em></a>, page <a href="ch06.html#page_189">189</a></li>
<li><a href="ch06.html#ch06lev1sec5"><em>Evil Wizards</em></a>, page <a href="ch06.html#page_198">198</a></li>
<li><a href="ch08.html#ch08lev1sec1"><em>Pragmatic Teams</em></a>, page <a href="ch08.html#page_224">224</a></li>
<li><a href="ch08.html#ch08lev1sec4"><em>It's All Writing</em></a>, page <a href="ch08.html#page_248">248</a></li>
</ul>
<p class="docText"><a id="ch02lev3sec6"></a></p>
<h5 id="title-IDA2ZN0" class="docSection3Title">Challenges</h5>
<ul>
<li>Consider the difference between large GUI-oriented tools typically found on Windows systems and small but combinable command line utilities used at shell prompts. Which set is more orthogonal, and why? Which is easier to use for exactly the purpose for which it was intended? Which set is easier to combine with other tools to meet new challenges?</li>
<li>C++ supports multiple inheritance, and Java allows a class to implement multiple interfaces. What impact does using these facilities have on orthogonality? Is there a difference in impact between using multiple inheritance and multiple interfaces? Is there a difference between using delegation and using inheritance?</li>
</ul>
<p class="docText"><a id="ch02lev2sec15"></a></p>
<h4 id="title-IDAS0N0" class="docSection2Title">Exercises</h4>
<p class="docText1"><a id="ch02que01"></a><strong><a href="app02.html#ch02ans01">1.</a></strong> You are writing a class called <code>Split</code>, which splits input lines into fields. Which of the following two Java class signatures is the more orthogonal design?</p>
<p class="progimage1"><img src="images/p0043-01.jpg" alt="image" /></p>
<p class="docText1"><a id="ch02que02"></a><strong><a href="app02.html#ch02ans02">2.</a></strong> Which will lead to a more orthogonal design: modeless or modal dialog boxes?</p>
<p class="docText1"><a id="ch02que03"></a><strong><a href="app02.html#ch02ans03">3.</a></strong> How about procedural languages versus object technology? Which results in a more orthogonal system?</p>
<p class="docText"><a id="ch02lev1sec3"></a><a id="page_44"></a></p>
<h3 id="title-IDA03N0" class="docSection1Title">9. Reversibility</h3>
<p class="blockquote"><em>Nothing is more dangerous than an idea if it's the only one you have.</em></p>
<p class="attribution">• <strong>Emil-Auguste Chartier,</strong> <strong><em>Propos sur la religion,</em></strong> <strong>1938</strong></p>
<p class="docText">Engineers prefer simple, single solutions to problems. Math tests that allow you to proclaim with great confidence that <em>x =</em> 2 are much more comfortable than fuzzy, warm essays about the myriad causes of the French Revolution. Management tends to agree with the engineers: single, easy answers fit nicely on spreadsheets and project plans.</p>
<p class="docText">If only the real world would cooperate! Unfortunately, while <em>x</em> is 2 today, it may need to be 5 tomorrow, and 3 next week. Nothing is forever—and if you rely heavily on some fact, you can almost guarantee that it <em>will</em> change.</p>
<p class="docText">There is always more than one way to implement something, and there is usually more than one vendor available to provide a third-party product. If you go into a project hampered by the myopic notion that there is only <em>one</em> way to do it, you may be in for an unpleasant surprise. Many project teams have their eyes forcibly opened as the future unfolds:</p>
<p class="blockquote"><em>"But you said we'd use database XYZ! We are 85% done coding the project, we can't change now!" the programmer protested. "Sorry, but our company decided to standardize on database PDQ instead—for all projects. It's out of my hands. We'll just have to recode. All of you will be working weekends until further notice."</em></p>
<p class="docText">Changes don't have to be that Draconian, or even that immediate. But as time goes by, and your project progresses, you may find yourself stuck in an untenable position. With every critical decision, the project team commits to a smaller target—a narrower version of reality that has fewer options.</p>
<p class="docText">By the time many critical decisions have been made, the target becomes so small that if it moves, or the wind changes direction, or a butterfly in Tokyo flaps its wings, you miss.<sup><a href="#ch02fn04">[4]</a></sup> And you may miss by a huge amount.</p>
<p class="docFootnote"><sup><a id="ch02fn04">[4]</a></sup> Take a nonlinear, or chaotic, system and apply a small change to one of its inputs. You may get a large and often unpredictable result. The clichéd butterfly flapping its wings in Tokyo could be the start of a chain of events that ends up generating a tornado in Texas. Does this sound like any projects you know?</p>
<p class="docText"><a id="page_45"></a>The problem is that critical decisions aren't easily reversible.</p>
<p class="docText">Once you decide to use this vendor's database, or that architectural pattern, or a certain deployment model (client-server versus standalone, for instance), you are committed to a course of action that cannot be undone, except at great expense.</p>
<p class="docText"><a id="ch02lev2sec16"></a></p>
<h4 id="title-IDANAO0" class="docSection2Title">Reversibility</h4>
<p class="docText">Many of the topics in this book are geared to producing flexible, adaptable software. By sticking to their recommendations—especially the <em>DRY</em> principle (page <a href="ch02.html#page_26">26</a>), decoupling (page <a href="ch05.html#page_138">138</a>), and use of metadata (page <a href="ch05.html#page_144">144</a>)—we don't have to make as many critical, irreversible decisions. This is a good thing, because we don't always make the best decisions the first time around. We commit to a certain technology only to discover we can't hire enough people with the necessary skills. We lock in a certain third-party vendor just before they get bought out by their competitor. Requirements, users, and hardware change faster than we can get the software developed.</p>
<p class="docText">Suppose you decide, early in the project, to use a relational database from vendor A. Much later, during performance testing, you discover that the database is simply too slow, but that the object database from vendor B is faster. With most conventional projects, you'd be out of luck. Most of the time, calls to third-party products are entangled throughout the code. But if you <em>really</em> abstracted the idea of a database out—to the point where it simply provides persistence as a service—then you have the flexibility to change horses in midstream.</p>
<p class="docText">Similarly, suppose the project begins as a client-server model, but then, late in the game, marketing decides that servers are too expensive for some clients, and they want a stand-alone version. How hard would that be for you? Since it's just a deployment issue, <em>it shouldn't take more than a few days.</em> If it would take longer, then you haven't thought about reversibility. The other direction is even more interesting. What if the stand-alone product you are making needs to be deployed in a client-server or <em>n</em>-tier fashion? <em>That shouldn't be hard either.</em></p>
<p class="docText">The mistake lies in assuming that any decision is cast in stone—and in not preparing for the contingencies that might arise. Instead of carving <a id="page_46"></a>decisions in stone, think of them more as being written in the sand at the beach. A big wave can come along and wipe them out at any time.</p>
<p class="docNoteTitle">Tip 14</p>
<p class="note"><a href="app03.html#id1e3201">There Are No Final Decisions</a></p>
<p class="docText"><a id="ch02lev2sec17"></a></p>
<h4 id="title-IDABCO0" class="docSection2Title">Flexible Architecture</h4>
<p class="docText">While many people try to keep their <em>code</em> flexible, you also need to think about maintaining flexibility in the areas of architecture, deployment, and vendor integration.</p>
<p class="docText">Technologies such as CORBA can help insulate portions of a project from changes in development language or platform. Is the performance of Java on that platform not up to expectations? Recode the client in C++, and nothing else needs to change. Is the rules engine in C++ not flexible enough? Switch over to a Smalltalk version. With a CORBA architecture, you have to take a hit only for the component you are replacing; the other components shouldn't be affected.</p>
<p class="docText">Are you developing for Unix? Which one? Do you have all of the portability concerns addressed? Are you developing for a particular version of Windows? Which one—3.1, 95, 98, NT, CE, or 2000? How hard will it be to support other versions? If you keep decisions soft and pliable, it won't be hard at all. If you have poor encapsulation, high coupling, and hard-coded logic or parameters in the code, it might be impossible.</p>
<p class="docText">Not sure how marketing wants to deploy the system? Think about it up front and you can support a stand-alone, client-server, or <em>n</em>-tier model just by changing a configuration file. We've written programs that do just that.</p>
<p class="docText">Normally, you can simply hide a third-party product behind a well-defined, abstract interface. In fact, we've always been able to do so on any project we've worked on. But suppose you couldn't isolate it that cleanly. What if you had to sprinkle certain statements liberally throughout the code? Put that requirement in metadata, and use some automatic mechanism, such as Aspects (see page <a href="ch02.html#page_39">39</a>) or Perl, to insert the necessary statements into the code itself. Whatever mechanism you <a id="page_47"></a>use, <em>make it reversible.</em> If something is added automatically, it can be taken out automatically as well.</p>
<p class="docText">No one knows what the future may hold, especially not us! So enable your code to rock-n-roll: to "rock on" when it can, to roll with the punches when it must.</p>
<p class="docText"><a id="ch02lev3sec7"></a></p>
<h5 id="title-IDACDO0" class="docSection3Title">Related sections include:</h5>
<ul>
<li><a href="ch05.html#ch05lev1sec1"><em>Decoupling and the Law of Demeter</em></a>, page <a href="ch05.html#page_138">138</a></li>
<li><a href="ch05.html#ch05lev1sec2"><em>Metaprogramming</em></a>, page <a href="ch05.html#page_144">144</a></li>
<li><a href="ch05.html#ch05lev1sec4"><em>It's Just a View</em></a>, page <a href="ch05.html#page_157">157</a></li>
</ul>
<p class="docText"><a id="ch02lev3sec8"></a></p>
<h5 id="title-IDADEO0" class="docSection3Title">Challenges</h5>
<ul>
<li>Time for a little quantum mechanics with Schrödinger's cat. Suppose you have a cat in a closed box, along with a radioactive particle. The particle has exactly a 50% chance of fissioning into two. If it does, the cat will be killed. If it doesn't, the cat will be okay. So, is the cat dead or alive? According to Schrödinger, the correct answer is <em>both.</em> Every time a sub-nuclear reaction takes place that has two possible outcomes, the universe is cloned. In one, the event occurred, in the other it didn't. The cat's alive in one universe, dead in another. Only when you open the box do you know which universe <em>you</em> are in.<br/><br/>No wonder coding for the future is difficult.<br/><br/>But think of code evolution along the same lines as a box full of Schrödinger's cats: every decision results in a different version of the future. How many possible futures can your code support? Which ones are more likely? How hard will it be to support them when the time comes?<br/><br/>Dare you open the box?</li>
</ul>
<p class="docText"><a id="ch02lev1sec4"></a><a id="page_48"></a></p>
<h3 id="title-IDAMFO0" class="docSection1Title">10. Tracer Bullets</h3>
<p class="docText"><em>Ready, fire, aim...</em></p>
<p class="docText">There are two ways to fire a machine gun in the dark.<sup><a href="#ch02fn05">[5]</a></sup> You can find out exactly where your target is (range, elevation, and azimuth). You can determine the environmental conditions (temperature, humidity, air pressure, wind, and so on). You can determine the precise specifications of the cartridges and bullets you are using, and their interactions with the actual gun you are firing. You can then use tables or a firing computer to calculate the exact bearing and elevation of the barrel. If everything works exactly as specified, your tables are correct, and the environment doesn't change, your bullets should land close to their target.</p>
<p class="docFootnote"><sup><a id="ch02fn05">[5]</a></sup> To be pedantic, there are many ways of firing a machine gun in the dark, including closing your eyes and spraying out bullets. But this is an analogy, and we're allowed to take liberties.</p>
<p class="docText">Or you could use tracer bullets.</p>
<p class="docText">Tracer bullets are loaded at intervals on the ammo belt alongside regular ammunition. When they're fired, their phosphorus ignites and leaves a pyrotechnic trail from the gun to whatever they hit. If the tracers are hitting the target, then so are the regular bullets.</p>
<p class="docText">Not surprisingly, tracer bullets are preferred to the labor of calculation. The feedback is immediate, and because they operate in the same environment as the real ammunition, external effects are minimized.</p>
<p class="docText">The analogy might be violent, but it applies to new projects, particularly when you're building something that hasn't been built before. Like the gunners, you're trying to hit a target in the dark. Because your users have never seen a system like this before, their requirements may be vague. Because you may be using algorithms, techniques, languages, or libraries you aren't familiar with, you face a large number of unknowns. And because projects take time to complete, you can pretty much guarantee the environment you're working in will change before you're done.</p>
<p class="docText">The classic response is to specify the system to death. Produce reams of paper itemizing every requirement, tying down every unknown, and <a id="page_49"></a>constraining the environment. Fire the gun using dead reckoning. One big calculation up front, then shoot and hope.</p>
<p class="docText">Pragmatic Programmers, however, tend to prefer using tracer bullets.</p>
<p class="docText"><a id="ch02lev2sec18"></a></p>
<h4 id="title-IDAPGO0" class="docSection2Title">Code That Glows in the Dark</h4>
<p class="docText">Tracer bullets work because they operate in the same environment and under the same constraints as the real bullets. They get to the target fast, so the gunner gets immediate feedback. And from a practical standpoint they're a relatively cheap solution.</p>
<p class="docText">To get the same effect in code, we're looking for something that gets us from a requirement to some aspect of the final system quickly, visibly, and repeatably.</p>
<p class="docNoteTitle">Tip 15</p>
<p class="note"><a href="app03.html#id1e3339">Use Tracer Bullets to Find the Target</a></p>
<p class="docText">We once undertook a complex client-server database marketing project. Part of its requirement was the ability to specify and execute temporal queries. The servers were a range of relational and specialized databases. The client GUI, written in Object Pascal, used a set of C libraries to provide an interface to the servers. The user's query was stored on the server in a Lisp-like notation before being converted to optimized SQL just prior to execution. There were many unknowns and many different environments, and no one was too sure how the GUI should behave.</p>
<p class="docText">This was a great opportunity to use tracer code. We developed the framework for the front end, libraries for representing the queries, and a structure for converting a stored query into a database-specific query. Then we put it all together and checked that it worked. For that initial build, all we could do was submit a query that listed all the rows in a table, but it proved that the UI could talk to the libraries, the libraries could serialize and unserialize a query, and the server could generate SQL from the result. Over the following months we gradually fleshed out this basic structure, adding new functionality by augmenting each component of the tracer code in parallel. When the UI added a new query type, the library grew and the SQL generation was made more sophisticated.</p>
<p class="docText"><a id="page_50"></a>Tracer code is not disposable: you write it for keeps. It contains all the error checking, structuring, documentation, and self-checking that any piece of production code has. It simply is not fully functional. However, once you have achieved an end-to-end connection among the components of your system, you can check how close to the target you are, adjusting if necessary. Once you're on target, adding functionality is easy.</p>
<p class="docText">Tracer development is consistent with the idea that a project is never finished: there will always be changes required and functions to add. It is an incremental approach.</p>
<p class="docText">The conventional alternative is a kind of heavy engineering approach: code is divided into modules, which are coded in a vacuum. Modules are combined into subassemblies, which are then further combined, until one day you have a complete application. Only then can the application as a whole be presented to the user and tested.</p>
<p class="docText">The tracer code approach has many advantages:</p>
<ul>
<li><a id="d1e3368"></a><strong>Users get to see something working early.</strong> If you have successfully communicated what you are doing (see <a href="ch08.html#ch08lev1sec5"><em>Great Expectations</em></a>, page <a href="ch08.html#page_255">255</a>), your users will know they are seeing something immature. They won't be disappointed by a lack of functionality; they'll be ecstatic to see some visible progress toward their system. They also get to contribute as the project progresses, increasing their buy-in. These same users will likely be the people who'll tell you how close to the target each iteration is.</li>
<li><a id="d1e3379"></a><strong>Developers build a structure to work in.</strong> The most daunting piece of paper is the one with nothing written on it. If you have worked out all the end-to-end interactions of your application, and have embodied them in code, then your team won't need to pull as much out of thin air. This makes everyone more productive, and encourages consistency.</li>
<li><a id="d1e3387"></a><strong>You have an integration platform.</strong> As the system is connected end-to-end, you have an environment to which you can add new pieces of code once they have been unit-tested. Rather than attempting a big-bang integration, you'll be integrating every day (often many times a day). The impact of each new change is more apparent, and the interactions are more limited, so debugging and testing are faster and more accurate.</li>
<li><a id="page_51"></a><a id="d1e3395"></a><strong>You have something to demonstrate.</strong> Project sponsors and top brass have a tendency to want to see demos at the most inconvenient times. With tracer code, you'll always have something to show them.</li>
<li><a id="d1e3403"></a><strong>You have a better feel for progress.</strong> In a tracer code development, developers tackle use cases one by one. When one is done, they move to the next. It is far easier to measure performance and to demonstrate progress to your user. Because each individual development is smaller, you avoid creating those monolithic blocks of code that are reported as 95% complete week after week.</li>
</ul>
<p class="docText"><a id="ch02lev2sec19"></a></p>
<h4 id="title-IDAPJO0" class="docSection2Title">Tracer Bullets Don't Always Hit Their Target</h4>
<p class="docText">Tracer bullets show what you're hitting. This may not always be the target. You then adjust your aim until they're on target. That's the point.</p>
<p class="docText">It's the same with tracer code. You use the technique in situations where you're not 100% certain of where you're going. You shouldn't be surprised if your first couple of attempts miss: the user says "that's not what I meant," or data you need isn't available when you need it, or performance problems seem likely. Work out how to change what you've got to bring it nearer the target, and be thankful that you've used a lean development methodology. A small body of code has low inertia—it is easy and quick to change. You'll be able to gather feedback on your application and generate a new, more accurate version faster and at less cost than with any other method. And because every major application component is represented in your tracer code, your users can be confident that what they're seeing is based on reality, not just a paper specification.</p>
<p class="docText"><a id="ch02lev2sec20"></a></p>
<h4 id="title-IDAAKO0" class="docSection2Title">Tracer Code versus Prototyping</h4>
<p class="docText">You might think that this tracer code concept is nothing more than prototyping under an aggressive name. There is a difference. With a prototype, you're aiming to explore specific aspects of the final system. With a true prototype, you will throw away whatever you lashed together when trying out the concept, and recode it properly using the lessons you've learned.</p>
<p class="docText">For example, say you're producing an application that helps shippers determine how to pack odd-sized boxes into containers. Among other <a id="page_52"></a>problems, the user interface needs to be intuitive and the algorithms you use to determine optimal packing are very complex.</p>
<p class="docText">You could prototype a user interface for your end users in a GUI tool. You code only enough to make the interface responsive to user actions. Once they've agreed to the layout, you might throw it away and recode it, this time with the business logic behind it, using the target language. Similarly, you might want to prototype a number of algorithms that perform the actual packing. You might code functional tests in a high-level, forgiving language such as Perl, and code low-level performance tests in something closer to the machine. In any case, once you'd made your decision, you'd start again and code the algorithms in their final environment, interfacing to the real world. This is <em>prototyping,</em> and it is very useful.</p>
<p class="docText">The tracer code approach addresses a different problem. You need to know how the application as a whole hangs together. You want to show your users how the interactions will work in practice, and you want to give your developers an architectural skeleton on which to hang code. In this case, you might construct a tracer consisting of a trivial implementation of the container packing algorithm (maybe something like first-come, first-served) and a simple but working user interface. Once you have all the components in the application plumbed together, you have a framework to show your users and your developers. Over time, you add to this framework with new functionality, completing stubbed routines. But the framework stays intact, and you know the system will continue to behave the way it did when your first tracer code was completed.</p>
<p class="docText">The distinction is important enough to warrant repeating. Prototyping generates disposable code. Tracer code is lean but complete, and forms part of the skeleton of the final system. Think of prototyping as the reconnaissance and intelligence gathering that takes place before a single tracer bullet is fired.</p>
<p class="docText"><a id="ch02lev3sec9"></a></p>
<h5 id="title-IDAVKO0" class="docSection3Title">Related sections include:</h5>
<ul>
<li><a href="ch01.html#ch01lev1sec4"><em>Good-Enough Software</em></a>, page <a href="ch01.html#page_9">9</a></li>
<li><a href="ch02.html#ch02lev1sec5"><em>Prototypes and Post-it Notes</em></a>, page <a href="ch02.html#page_53">53</a></li>
<li><a href="ch07.html#ch07lev1sec4"><em>The Specification Trap</em></a>, page <a href="ch07.html#page_217">217</a></li>
<li><a href="ch08.html#ch08lev1sec5"><em>Great Expectations</em></a>, page <a href="ch08.html#page_255">255</a></li>
</ul>
<p class="docText"><a id="ch02lev1sec5"></a><a id="page_53"></a></p>
<h3 id="title-IDA4LO0" class="docSection1Title">11. Prototypes and Post-it Notes</h3>
<p class="docText">Many different industries use prototypes to try out specific ideas; prototyping is much cheaper than full-scale production. Car makers, for example, may build many different prototypes of a new car design. Each one is designed to test a specific aspect of the car—the aerodynamics, styling, structural characteristics, and so on. Perhaps a clay model will be built for wind tunnel testing, maybe a balsa wood and duct tape model will do for the art department, and so on. Some car companies take this a step further, and now do a great deal of modeling work on the computer, reducing costs even further. In this way, risky or uncertain elements can be tried out without committing to building the real item.</p>
<p class="docText">We build software prototypes in the same fashion, and for the same reasons—to analyze and expose risk, and to offer chances for correction at a greatly reduced cost. Like the car makers, we can target a prototype to test one or more specific aspects of a project.</p>
<p class="docText">We tend to think of prototypes as code-based, but they don't always have to be. Like the car makers, we can build prototypes out of different materials. Post-it notes are great for prototyping dynamic things such as workflow and application logic. A user interface can be prototyped as a drawing on a whiteboard, as a nonfunctional mock-up drawn with a paint program, or with an interface builder.</p>
<p class="docText">Prototypes are designed to answer just a few questions, so they are much cheaper and faster to develop than applications that go into production. The code can ignore unimportant details—unimportant to you at the moment, but probably very important to the user later on. If you are prototyping a GUI, for instance, you can get away with incorrect results or data. On the other hand, if you're just investigating computational or performance aspects, you can get away with a pretty poor GUI, or perhaps even no GUI at all.</p>
<p class="docText">But if you find yourself in an environment where you <em>cannot</em> give up the details, then you need to ask yourself if you are really building a prototype at all. Perhaps a tracer bullet style of development would be more appropriate in this case (see <a href="ch02.html#ch02lev1sec4"><em>Tracer Bullets</em></a>, page <a href="ch02.html#page_48">48</a>).</p>
<p class="docText"><a id="ch02lev2sec21"></a><a id="page_54"></a></p>
<h4 id="title-IDADNO0" class="docSection2Title">Things to Prototype</h4>
<p class="docText">What sorts of things might you choose to investigate with a prototype? Anything that carries risk. Anything that hasn't been tried before, or that is absolutely critical to the final system. Anything unproven, experimental, or doubtful. Anything you aren't comfortable with. You can prototype</p>
<ul>
<li>Architecture</li>
<li>New functionality in an existing system</li>
<li>Structure or contents of external data</li>
<li>Third-party tools or components</li>
<li>Performance issues</li>
<li>User interface design</li>
</ul>
<p class="docText">Prototyping is a learning experience. Its value lies not in the code produced, but in the lessons learned. That's really the point of prototyping.</p>
<p class="docNoteTitle">Tip 16</p>
<p class="note"><a href="app03.html#id1e3540">Prototype to Learn</a></p>
<p class="docText"><a id="ch02lev2sec22"></a></p>
<h4 id="title-IDAPOO0" class="docSection2Title">How to Use Prototypes</h4>
<p class="docText">When building a prototype, what details can you ignore?</p>
<ul>
<li><a id="d1e3559"></a><strong>Correctness.</strong> You may be able to use dummy data where appropriate.</li>
<li><a id="d1e3567"></a><strong>Completeness.</strong> The prototype may function only in a very limited sense, perhaps with only one preselected piece of input data and one menu item.</li>
<li><a id="d1e3575"></a><strong>Robustness.</strong> Error checking is likely to be incomplete or missing entirely. If you stray from the predefined path, the prototype may crash and burn in a glorious display of pyrotechnics. That's okay.</li>
<li><a id="d1e3583"></a><strong>Style.</strong> It is painful to admit this in print, but prototype code probably doesn't have much in the way of comments or documentation. You may produce reams of documentation as a result of your experience with the prototype, but comparatively very little on the prototype system itself.</li>
</ul>
<p class="docText"><a id="page_55"></a>Since a prototype should gloss over details, and focus in on specific aspects of the system being considered, you may want to implement prototypes using a very high-level language—higher than the rest of the project (maybe a language such as Perl, Python, or Tcl). A high-level scripting language lets you defer many details (including specifying data types) and still produce a functional (albeit incomplete or slow) piece of code.<sup><a href="#ch02fn06">[6]</a></sup> If you need to prototype user interfaces, investigate tools such as Tcl/Tk, Visual Basic, Powerbuilder, or Delphi.</p>
<p class="docFootnote"><sup><a id="ch02fn06">[6]</a></sup> If you are investigating absolute (instead of relative) performance, you will need to stick to a language that is close in performance to the target language.</p>
<p class="docText">Scripting languages work well as the "glue" to combine low-level pieces into new combinations. Under Windows, Visual Basic can glue together COM controls. More generally, you can use languages such as Perl and Python to bind together low-level C libraries—either by hand, or automatically with tools such as the freely available SWIG [<a href="app01.html#app01lev3sec28">URL 28</a>]. Using this approach, you can rapidly assemble existing components into new configurations to see how things work.</p>
<p class="docText"><a id="ch02lev2sec23"></a></p>
<h4 id="title-IDABRO0" class="docSection2Title">Prototyping Architecture</h4>
<p class="docText">Many prototypes are constructed to model the entire system under consideration. As opposed to tracer bullets, none of the individual modules in the prototype system need to be particularly functional. In fact, you may not even need to code in order to prototype architecture—you can prototype on a whiteboard, with Post-it notes or index cards. What you are looking for is how the system hangs together as a whole, again deferring details. Here are some specific areas you may want to look for in the architectural prototype:</p>
<ul>
<li>Are the responsibilities of the major components well defined and appropriate?</li>
<li>Are the collaborations between major components well defined?</li>
<li>Is coupling minimized?</li>
<li>Can you identify potential sources of duplication?</li>
<li>Are interface definitions and constraints acceptable?</li>
<li><a id="page_56"></a>Does every module have an access path to the data it needs during execution? Does it have that access <em>when</em> it needs it?</li>
</ul>
<p class="docText">This last item tends to generate the most surprises and the most valuable results from the prototyping experience.</p>
<p class="docText"><a id="ch02lev2sec24"></a></p>
<h4 id="title-IDANSO0" class="docSection2Title">How <em>Not</em> to Use Prototypes</h4>
<p class="docText">Before you embark on any code-based prototyping, make sure that everyone understands that you are writing disposable code. Prototypes can be deceptively attractive to people who don't know that they are just prototypes. You must make it <em>very</em> clear that this code is disposable, incomplete, and unable to be completed.</p>
<p class="docText">It's easy to become misled by the apparent completeness of a demonstrated prototype, and project sponsors or management may insist on deploying the prototype (or its progeny) if you don't set the right expectations. Remind them that you can build a great prototype of a new car out of balsa wood and duct tape, but you wouldn't try to drive it in rush-hour traffic!</p>
<p class="docText">If you feel there is a strong possibility in your environment or culture that the purpose of prototype code may be misinterpreted, you may be better off with the tracer bullet approach. You'll end up with a solid framework on which to base future development.</p>
<p class="docText">When used properly, a prototype can save you huge amounts of time, money, pain, and suffering by identifying and correcting potential problem spots early in the development cycle—the time when fixing mistakes is both cheap and easy.</p>
<p class="docText"><a id="ch02lev3sec10"></a></p>
<h5 id="title-IDAGTO0" class="docSection3Title">Related sections include:</h5>
<ul>
<li><a href="ch01.html#ch01lev1sec1"><em>The Cat Ate My Source Code</em></a>, page <a href="ch01.html#page_2">2</a></li>
<li><a href="ch01.html#ch01lev1sec6"><em>Communicate!</em></a>, page <a href="ch01.html#page_18">18</a></li>
<li><a href="ch02.html#ch02lev1sec4"><em>Tracer Bullets</em></a>, page <a href="ch02.html#page_48">48</a></li>
<li><a href="ch08.html#ch08lev1sec5"><em>Great Expectations</em></a>, page <a href="ch08.html#page_255">255</a></li>
</ul>
<p class="docText"><a id="ch02lev2sec25"></a></p>
<h4 id="title-IDAOUO0" class="docSection2Title">Exercises</h4>
<p class="docText1"><a id="ch02que04"></a><strong><a href="app02.html#ch02ans04">4</a>.</strong> Marketing would like to sit down and brainstorm a few Web-page designs with you. They are thinking of clickable image maps to take you to other pages, and so on. But they can't decide on a model for the image—maybe <a id="page_57"></a>it's a car, or a phone, or a house. You have a list of target pages and content; they'd like to see a few prototypes. Oh, by the way, you have 15 minutes. What tools might you use?</p>
<p class="docText"><a id="ch02lev1sec6"></a></p>
<h3 id="title-IDAKVO0" class="docSection1Title">12. Domain Languages</h3>
<p class="blockquote"><em>The limits of language are the limits of one's world.</em></p>
<p class="attribution">• <strong>Ludwig Wittgenstein</strong></p>
<p class="docText">Computer languages influence <em>how</em> you think about a problem, and how you think about communicating. Every language comes with a list of features—buzzwords such as static versus dynamic typing, early versus late binding, inheritance models (single, multiple, or none)—all of which may suggest or obscure certain solutions. Designing a solution with Lisp in mind will produce different results than a solution based on C-style thinking, and vice versa. Conversely, and we think more importantly, the language of the problem domain may also suggest a programming solution.</p>
<p class="docText">We always try to write code using the vocabulary of the application domain (see <a href="ch07.html#ch07lev1sec1"><em>The Requirements Pit</em></a>, page <a href="ch07.html#page_210">210</a>, where we suggest using a project glossary). In some cases, we can go to the next level and actually program using the vocabulary, syntax, and semantics—the language—of the domain.</p>
<p class="docText">When you listen to users of a proposed system, they might be able to tell you exactly how the system should work:</p>
<p class="blockquote"><em>Listen for transactions defined by ABC Regulation 12.3 on a set of X.25 lines, translate them to XYZ Company's format 43B, retransmit them on the satellite uplink, and store for future analysis.</em></p>
<p class="docText">If your users have a number of such well-bounded statements, you can invent a mini-language tailored to the application domain that expresses exactly what they want:</p>
<p class="programlisting">        From X25LINE1 (Format=ABC123) {<br/>            Put TELSTAR1 (Format=XYZ43B);<br/>            Store DB;<br/>        }</p>
<p class="docText"><a id="page_58"></a>This language need not be executable. Initially, it could be simply a way of capturing the user's requirements—a specification. However, you may want to consider taking this a step further and actually implementing the language. Your specification has become executable code.</p>
<p class="docText">After you've written the application, the users give you a new requirement: transactions with negative balances shouldn't be stored, and should be sent back on the X.25 lines in the original format:</p>
<p class="progimage"><img src="images/p0058-01.jpg" alt="image" /></p>
<p class="docText">That was easy, wasn't it? With the proper support in place, you can program much closer to the application domain. We're not suggesting that your end users actually program in these languages. Instead, you're giving yourself a tool that lets you work closer to their domain.</p>
<p class="docNoteTitle">Tip 17</p>
<p class="note"><a href="app03.html#id1e3773">Program Close to the Problem Domain</a></p>
<p class="docText">Whether it's a simple language to configure and control an application program, or a more complex language to specify rules or procedures, we think you should consider ways of moving your project closer to the problem domain. By coding at a higher level of abstraction, you are free to concentrate on solving domain problems, and can ignore petty implementation details.</p>
<p class="docText">Remember that there are many users of an application. There's the end user, who understands the business rules and the required outputs. There are also secondary users: operations staff, configuration and test managers, support and maintenance programmers, and future generations of developers. Each of these users has their own problem domain, and you can generate mini-environments and languages for all of them.</p>
<p class="docText"><a id="page_59"></a></p>
<div class="sidebar1">
<p class="docSidebarTitle">Domain-Specific Errors</p>
<p class="sidebar">If you are writing in the problem domain, you can also perform domain-specific validation, reporting problems in terms your users can understand. Take our switching application on on the facing page. Suppose the user misspelled the format name:</p>
<p class="programlisting">        From X25LINE1 (Format=AB123)</p>
<p class="sidebar">If this happened in a standard, general-purpose programming language, you might receive a standard, general-purpose error message:</p>
<p class="programlisting">        Syntax error: undeclared identifier</p>
<p class="sidebar">But with a mini-language, you would instead be able to issue an error message using the vocabulary of the domain:</p>
<p class="programlisting">        "AB123" is not a format. Known formats are ABC123,<br/>                        XYZ43B, PDQB, and 42.<br/></p>
</div>
<p class="docText"><a id="ch02lev2sec26"></a></p>
<h4 id="title-IDAGZO0" class="docSection2Title">Implementing a Mini-Language</h4>
<p class="docText">At its simplest, a mini-language may be in a line-oriented, easily parsed format. In practice, we probably use this form more than any other. It can be parsed simply using <code>switch</code> statements, or using regular expressions in scripting languages such as Perl. The answer to Exercise 5 on page <a href="app02.html#page_281">281</a> shows a simple implementation in C.</p>
<p class="docText">You can also implement a more complex language, with a more formal syntax. The trick here is to define the syntax first using a notation such as BNF.<sup><a href="#ch02fn07">[7]</a></sup> Once you have your grammar specified, it is normally trivial to convert it into the input syntax for a parser generator. C and C++ programmers have been using <code>yacc</code> (or its freely available implementation, <code>bison</code> [<a href="app01.html#app01lev3sec27">URL 27</a>]) for years. These programs are documented in detail in the book <em>Lex and Yacc</em> [<a href="app01.html#lmb92">LMB92</a>]. Java programmers can try <code>javaCC,</code> which can be found at [<a href="app01.html#app01lev3sec26">URL 26</a>]. The answer to Exercise 7 on page <a href="app02.html#page_282">282</a> <a id="page_60"></a>shows a parser written using <code>bison</code>. As it shows, once you know the syntax, it's really not a lot of work to write simple mini-languages.</p>
<p class="docFootnote"><sup><a id="ch02fn07">[7]</a></sup> BNF, or Backus-Naur Form, lets you specify <em>context-free</em> grammars recursively. Any good book on compiler construction or parsing will cover BNF in (exhaustive) detail.</p>
<p class="docText">There's another way of implementing a mini-language: extend an existing one. For example, you could integrate application-level functionality with (say) Python [<a href="app01.html#app01lev3sec9">URL 9</a>] and write something like<sup><a href="#ch02fn08">[8]</a></sup></p>
<p class="docFootnote"><sup><a id="ch02fn08">[8]</a></sup> Thanks to Eric Vought for this example.</p>
<p class="programlisting">        record = X25LINE1.get(format=ABC123)<br/>        <strong>if</strong> (record.balance &lt; 0):<br/>                       X25LINE1.put(record, format=ABC123)<br/>        <strong>else:</strong><br/>                       TELSTAR1.put(record, format=XYZ43B)<br/>                       DB.store(record)<br/></p>
<p class="docText"><a id="ch02lev3sec11"></a></p>
<h5 id="title-IDAQ1O0" class="docSection3Title">Data Languages and Imperative Languages</h5>
<p class="docText">The languages you implement can be used in two different ways.</p>
<p class="docText"><em>Data languages</em> produce some form of data structure used by an application. These languages are often used to represent configuration information.</p>
<p class="docText">For example, the <code>sendmail</code> program is used throughout the world for routing e-mail over the Internet. It has many excellent features and benefits, which are controlled by a thousand-line configuration file, written using <code>sendmail</code>'s own configuration language:</p>
<p class="programlisting">        Mlocal,  P=/usr/bin/procmail,<br/>                     F=lsDFMAw5 :/|@qSPfhn9,<br/>                     S=10/30, R=20/40,<br/>                     T=DNS/RFC822/X-Unix,<br/>                     A=procmail -Y -a $h -d $u</p>
<p class="docText">Obviously, readability is not one of <code>sendmail</code>'s strengths.</p>
<p class="docText">For years, Microsoft has been using a data language that can describe menus, widgets, dialog boxes, and other Windows resources. <a href="#ch02fig02">Figure 2.2</a> on the next page shows an excerpt from a typical resource file. This is far easer to read than the <code>sendmail</code> example, but it is used in exactly the same way—it is compiled to generate a data structure.</p>
<p class="docText"><a id="ch02fig02"></a></p>
<p class="docFigureTitle">Figure 2.2. Windows .rc file</p>
<p class="image"><img src="images/f02fig02.gif" alt="image" /></p>
<p class="docText"><em>Imperative languages</em> take this a step further. Here the language is actually executed, and so can contain statements, control constructs, and the like (such as the script on page <a href="ch02.html#page_58">58</a>).</p>
<p class="docText"><a id="page_61"></a>You can also use your own imperative languages to ease program maintenance. For example, you may be asked to integrate information from a legacy application into your new GUI development. A common way of achieving this is by <em>screen scraping;</em> your application connects to the mainframe application as if it were a regular human user, issuing keystrokes and "reading" the responses it gets back. You could script the interaction using a mini-language.<sup><a href="#ch02fn09">[9]</a></sup></p>
<p class="docFootnote"><sup><a id="ch02fn09">[9]</a></sup> In fact, you can buy tools that support just this kind of scripting. You can also investigate open-source packages such as Expect, which provide similar capabilities [<a href="app01.html#app01lev3sec24">URL 24</a>].</p>
<p class="progimage"><img src="images/p0061-02.jpg" alt="image" /></p>
<p class="docText">When the application determines it is time to enter a Social Security number, it invokes the interpreter on this script, which then controls <a id="page_62"></a>the transaction. If the interpreter is embedded within the application, the two can even share data directly (for example, via a callback mechanism).</p>
<p class="docText">Here you're programming in the maintenance programmer's domain. When the mainframe application changes, and the fields move around, the programmer can simply update your high-level description, rather than groveling around in the details of C code.</p>
<p class="docText"><a id="ch02lev3sec12"></a></p>
<h5 id="title-IDAQ4O0" class="docSection3Title">Stand-Alone and Embedded Languages</h5>
<p class="docText">A mini-language doesn't have to be used directly by the application to be useful. Many times we may use a specification language to create artifacts (including metadata) that are compiled, read-in, or otherwise used by the program itself (see <a href="ch05.html#ch05lev1sec2"><em>Metaprogramming</em></a>, page <a href="ch05.html#page_144">144</a>).</p>
<p class="docText">For example, on page <a href="ch03.html#page_100">100</a> we describe a system in which we used Perl to generate a large number of derivations from an original schema specification. We invented a common language to express the database schema, and then generated all the forms of it we needed—SQL, C, Web pages, XML, and others. The application didn't use the specification directly, but it relied on the output produced from it.</p>
<p class="docText">It is common to embed high-level imperative languages directly into your application, so that they execute when your code runs. This is clearly a powerful capability; you can change your application's behavior by changing the scripts it reads, all without compiling. This can significantly simplify maintenance in a dynamic application domain.</p>
<p class="docText"><a id="ch02lev3sec13"></a></p>
<h5 id="title-IDAI5O0" class="docSection3Title">Easy Development or Easy Maintenance?</h5>
<p class="docText">We've looked at several different grammars, ranging from simple line-oriented formats to more complex grammars that look like real languages. Since it takes extra effort to implement, why would you choose a more complex grammar?</p>
<p class="docText">The trade-off is extendibility and maintenance. While the code for parsing a "real" language may be harder to write, it will be much easier for people to understand, and to extend in the future with new features and functionality. Languages that are too simple may be easy to parse, but can be cryptic—much like the <code>sendmail</code> example on page <a href="ch02.html#page_60">60</a>.</p>
<p class="docText"><a id="page_63"></a>Given that most applications exceed their expected lifetimes, you're probably better off biting the bullet and adopting the more complex and readable language up front. The initial effort will be repaid many times in reduced support and maintenance costs.</p>
<p class="docText"><a id="ch02lev3sec14"></a></p>
<h5 id="title-IDA35O0" class="docSection3Title">Related sections include:</h5>
<ul>
<li><a href="ch05.html#ch05lev1sec2"><em>Metaprogramming</em></a>, page <a href="ch05.html#page_144">144</a></li>
</ul>
<p class="docText"><a id="ch02lev3sec15"></a></p>
<h5 id="title-IDAVAP0" class="docSection3Title">Challenges</h5>
<ul>
<li>Could some of the requirements of your current project be expressed in a domain-specific language? Would it be possible to write a compiler or translator that could generate most of the code required?</li>
<li>If you decide to adopt mini-languages as a way of programming closer to the problem domain, you're accepting that some effort will be required to implement them. Can you see ways in which the framework you develop for one project can be reused in others?</li>
</ul>
<p class="docText"><a id="ch02lev2sec27"></a></p>
<h4 id="title-IDALBP0" class="docSection2Title">Exercises</h4>
<p class="docText1"><a id="ch02que05"></a><strong><a href="app02.html#ch02ans05">5</a>.</strong> We want to implement a mini-language to control a simple drawing package (perhaps a turtle-graphics system). The language consists of single-letter commands. Some commands are followed by a single number. For example, the following input would draw a rectangle.</p>
<p class="progimage1"><img src="images/p0063-01.jpg" alt="image" /></p>
<p class="docText1"><a id="ch02que06"></a><strong><a href="app02.html#ch02ans06">6</a>.</strong> Design a BNF grammar to parse a time specification. All of the following examples should be accepted.</p>
<p class="programlisting1">        4pm,  7:38pm,  23:42,  3:16,  3:16am</p>
<p class="docText1"><a id="ch02que07"></a><strong><a href="app02.html#ch02ans07">7</a>.</strong> Implement a parser for the BNF grammar in Exercise 6 using <code>yacc</code>, <code>bison</code>, or a similar parser-generator.</p>
<p class="docText1"><a id="ch02que08"></a><strong><a href="app02.html#ch02ans08">8</a>.</strong> Implement the time parser using Perl. [<em>Hint:</em> Regular expressions make good parsers.]</p>
<p class="docText"><a id="ch02lev1sec7"></a><a id="page_64"></a></p>
<h3 id="title-IDALEP0" class="docSection1Title">13. Estimating</h3>
<p class="docText">Quick! How long will it take to send <em>War and Peace</em> over a 56k modem line? How much disk space will you need for a million names and addresses? How long does a 1,000-byte block take to pass through a router? How many months will it take to deliver your project?</p>
<p class="docText">At one level, these are all meaningless questions—they are all missing information. And yet they can all be answered, as long as you are comfortable estimating. And, in the process of producing an estimate, you'll come to understand more about the world your programs inhabit.</p>
<p class="docText">By learning to estimate, and by developing this skill to the point where you have an intuitive feel for the magnitudes of things, you will be able to show an apparent magical ability to determine their feasibility. When someone says "we'll send the backup over an ISDN line to the central site," you'll be able to know intuitively whether this is practical. When you're coding, you'll be able to know which subsystems need optimizing and which ones can be left alone.</p>
<p class="docNoteTitle">Tip 18</p>
<p class="note"><a href="app03.html#id1e4132">Estimate to Avoid Surprises</a></p>
<p class="docText">As a bonus, at the end of this section we'll reveal the single correct answer to give whenever anyone asks you for an estimate.</p>
<p class="docText"><a id="ch02lev2sec28"></a></p>
<h4 id="title-IDAJFP0" class="docSection2Title">How Accurate Is Accurate Enough?</h4>
<p class="docText">To some extent, all answers are estimates. It's just that some are more accurate than others. So the first question you have to ask yourself when someone asks you for an estimate is the context in which your answer will be taken. Do they need high accuracy, or are they looking for a ballpark figure?</p>
<ul>
<li>If your grandmother asks when you will arrive, she's probably wondering whether to make you lunch or dinner. On the other hand, a diver trapped underwater and running out of air is probably interested in an answer down to the second.</li>
<li><a id="page_65"></a>What's the value of π? If you're wondering how much edging to buy to put around a circular flower bed, then "3" is probably good enough.<sup><a href="#ch02fn10">[10]</a></sup> If you're in school, then maybe "22/7" is a good approximation. If you're in NASA, then maybe 12 decimal places will do.<br/>
<p class="docFootnote"><sup><a id="ch02fn10">[10]</a></sup> "3" is also apparently good enough if you are a legislator. In 1897, Indiana State Legislature House Bill No. 246 attempted to decree that henceforth π should have the value of "3". The Bill was tabled indefinitely at its second reading when a mathematics professor pointed out that their powers did not quite extend to passing laws of nature.</p></li>
</ul>
<p class="docText">One of the interesting things about estimating is that the units you use make a difference in the interpretation of the result. If you say that something will take about 130 working days, then people will be expecting it to come in pretty close. However, if you say "Oh, about six months," then they know to look for it any time between five and seven months from now. Both numbers represent the same duration, but "130 days" probably implies a higher degree of accuracy than you feel. We recommend that you scale time estimates as follows:</p>
<p class="image"><img src="images/t0065-01.gif" alt="image" /></p>
<p class="docText">So, if after doing all the necessary work, you decide that a project will take 125 working days (25 weeks), you might want to deliver an estimate of "about six months."</p>
<p class="docText">The same concepts apply to estimates of any quantity: choose the units of your answer to reflect the accuracy you intend to convey.</p>
<p class="docText"><a id="ch02lev2sec29"></a></p>
<h4 id="title-IDAQJP0" class="docSection2Title">Where Do Estimates Come From?</h4>
<p class="docText">All estimates are based on models of the problem. But before we get too deeply into the techniques of building models, we have to mention a basic estimating trick that always gives good answers: ask someone who's already done it. Before you get too committed to model building, cast around for someone who's been in a similar situation in the past.</p>
<p class="docText"><a id="page_66"></a>See how their problem got solved. It's unlikely you'll ever find an exact match, but you'd be surprised how many times you can successfully draw on other's experiences.</p>
<p class="docText"><a id="ch02lev3sec16"></a></p>
<h5 id="title-IDA2JP0" class="docSection3Title">Understand What's Being Asked</h5>
<p class="docText">The first part of any estimation exercise is building an understanding of what's being asked. As well as the accuracy issues discussed above, you need to have a grasp of the scope of the domain. Often this is implicit in the question, but you need to make it a habit to think about the scope before starting to guess. Often, the scope you choose will form part of the answer you give: "Assuming there are no traffic accidents and there's gas in the car, I should be there in 20 minutes."</p>
<p class="docText"><a id="ch02lev3sec17"></a></p>
<h5 id="title-IDAHKP0" class="docSection3Title">Build a Model of the System</h5>
<p class="docText">This is the fun part of estimating. From your understanding of the question being asked, build a rough and ready bare-bones mental model. If you're estimating response times, your model may involve a server and some kind of arriving traffic. For a project, the model may be the steps that your organization uses during development, along with a very rough picture of how the system might be implemented.</p>
<p class="docText">Model building can be both creative and useful in the long term. Often, the process of building the model leads to discoveries of underlying patterns and processes that weren't apparent on the surface. You may even want to reexamine the original question: "You asked for an estimate to do <em>X.</em> However, it looks like <em>Y,</em> a variant of <em>X,</em> could be done in about half the time, and you lose only one feature."</p>
<p class="docText">Building the model introduces inaccuracies into the estimating process. This is inevitable, and also beneficial. You are trading off model simplicity for accuracy. Doubling the effort on the model may give you only a slight increase in accuracy. Your experience will tell you when to stop refining.</p>
<p class="docText"><a id="ch02lev3sec18"></a></p>
<h5 id="title-IDA3KP0" class="docSection3Title">Break the Model into Components</h5>
<p class="docText">Once you have a model, you can decompose it into components. You'll need to discover the mathematical rules that describe how these components interact. Sometimes a component contributes a single value <a id="page_67"></a>that is added into the result. Some components may supply multiplying factors, while others may be more complicated (such as those that simulate the arrival of traffic at a node).</p>
<p class="docText">You'll find that each component will typically have parameters that affect how it contributes to the overall model. At this stage, simply identify each parameter.</p>
<p class="docText"><a id="ch02lev3sec19"></a></p>
<h5 id="title-IDAKLP0" class="docSection3Title">Give Each Parameter a Value</h5>
<p class="docText">Once you have the parameters broken out, you can go through and assign each one a value. You expect to introduce some errors in this step. The trick is to work out which parameters have the most impact on the result, and concentrate on getting them about right. Typically, parameters whose values are added into a result are less significant than those that are multiplied or divided. Doubling a line speed may double the amount of data received in an hour, while adding a 5 ms transit delay will have no noticeable effect.</p>
<p class="docText">You should have a justifiable way of calculating these critical parameters. For the queuing example, you might want to measure the actual transaction arrival rate of the existing system, or find a similar system to measure. Similarly, you could measure the current time taken to serve a request, or come up with an estimate using the techniques described in this section. In fact, you'll often find yourself basing an estimate on other subestimates. This is where your largest errors will creep in.</p>
<p class="docText"><a id="ch02lev3sec20"></a></p>
<h5 id="title-IDAXLP0" class="docSection3Title">Calculate the Answers</h5>
<p class="docText">Only in the simplest of cases will an estimate have a single answer. You might be happy to say "I can walk five cross-town blocks in 15 minutes." However, as the systems get more complex, you'll want to hedge your answers. Run multiple calculations, varying the values of the critical parameters, until you work out which ones really drive the model. A spreadsheet can be a big help. Then couch your answer in terms of these parameters. "The response time is roughly three quarters of a second if the system has a SCSI bus and 64MB memory, and one second with 48MB memory." (Notice how "three quarters of a second" conveys a different feeling of accuracy than 750 ms.)</p>
<p class="docText"><a id="page_68"></a>During the calculation phase, you may start getting answers that seem strange. Don't be too quick to dismiss them. If your arithmetic is correct, your understanding of the problem or your model is probably wrong. This is valuable information.</p>
<p class="docText"><a id="ch02lev3sec21"></a></p>
<h5 id="title-IDAEMP0" class="docSection3Title">Keep Track of Your Estimating Prowess</h5>
<p class="docText">We think it's a great idea to record your estimates so you can see how close you were. If an overall estimate involved calculating subestimates, keep track of these as well. Often you'll find your estimates are pretty good—in fact, after a while, you'll come to expect this.</p>
<p class="docText">When an estimate turns out wrong, don't just shrug and walk away. Find out why it differed from your guess. Maybe you chose some parameters that didn't match the reality of the problem. Maybe your model was wrong. Whatever the reason, take some time to uncover what happened. If you do, your next estimate will be better.</p>
<p class="docText"><a id="ch02lev2sec30"></a></p>
<h4 id="title-IDAWMP0" class="docSection2Title">Estimating Project Schedules</h4>
<p class="docText">The normal rules of estimating can break down in the face of the complexities and vagaries of a sizable application development. We find that often the only way to determine the timetable for a project is by gaining experience on that same project. This needn't be a paradox if you practice incremental development, repeating the following steps.</p>
<ul>
<li>Check requirements</li>
<li>Analyze risk</li>
<li>Design, implement, integrate</li>
<li>Validate with the users</li>
</ul>
<p class="docText">Initially, you may have only a vague idea of how many iterations will be required, or how long they may be. Some methods require you to nail this down as part of the initial plan, but for all but the most trivial of projects this is a mistake. Unless you are doing an application similar to a previous one, with the same team and the same technology, you'd just be guessing.</p>
<p class="docText">So you complete the coding and testing of the initial functionality and mark this as the end of the first increment. Based on that experience, you can refine your initial guess on the number of iterations and what <a id="page_69"></a>can be included in each. The refinement gets better and better each time, and confidence in the schedule grows along with it.</p>
<p class="docNoteTitle">Tip 19</p>
<p class="note"><a href="app03.html#id1e4364">Iterate the Schedule with the Code</a></p>
<p class="docText">This may not be popular with management, who typically want a single, hard-and-fast number before the project even starts. You'll have to help them understand that the team, their productivity, and the environment will determine the schedule. By formalizing this, and refining the schedule as part of each iteration, you'll be giving them the most accurate scheduling estimates you can.</p>
<p class="docText"><a id="ch02lev2sec31"></a></p>
<h4 id="title-IDAOOP0" class="docSection2Title">What to Say When Asked for an Estimate</h4>
<p class="docText">You say <em>"I'll get back to you."</em></p>
<p class="docText">You almost always get better results if you slow the process down and spend some time going through the steps we describe in this section. Estimates given at the coffee machine will (like the coffee) come back to haunt you.</p>
<p class="docText"><a id="ch02lev3sec22"></a></p>
<h5 id="title-IDA3OP0" class="docSection3Title">Related sections include:</h5>
<ul>
<li><a href="ch06.html#ch06lev1sec2"><em>Algorithm Speed</em></a>, page <a href="ch06.html#page_177">177</a></li>
</ul>
<p class="docText"><a id="ch02lev3sec23"></a></p>
<h5 id="title-IDASPP0" class="docSection3Title">Challenges</h5>
<ul>
<li>Start keeping a log of your estimates. For each, track how accurate you turned out to be. If your error was greater than 50%, try to find out where your estimate went wrong.</li>
</ul>
<p class="docText"><a id="ch02lev2sec32"></a></p>
<h4 id="title-IDAIQP0" class="docSection2Title">Exercises</h4>
<p class="docText1"><a id="ch02que09"></a><strong><a href="app02.html#ch02ans09">9</a>.</strong> You are asked "Which has a higher bandwidth: a 1Mbps communications line or a person walking between two computers with a full 4GB tape in their pocket?" What constraints will you put on your answer to ensure that the scope of your response is correct? (For example, you might say that the time taken to access the tape is ignored.)</p>
<p class="docText1"><a id="ch02que10"></a><strong><a href="app02.html#ch02ans10">10</a>.</strong> So, which has the higher bandwidth?</p>
</div>
</body>
</html>